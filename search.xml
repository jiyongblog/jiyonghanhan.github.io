<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++数据输入cin</title>
    <url>/2020/07/21/C-%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5cin/</url>
    <content><![CDATA[<h3 id="cin-get-与cin-peek"><a href="#cin-get-与cin-peek" class="headerlink" title="cin.get()与cin.peek()"></a>cin.get()与cin.peek()</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ char c;</span><br><span class="line">$ c=cin.peek();</span><br><span class="line">//查看放回缓存区。如果要访问的字符是文件结束符，则函数值是EOF（-1）。</span><br><span class="line"></span><br><span class="line">$ ch=cin.get();//从输入流中读取一个字符,会读取回车</span><br><span class="line">$ cin.get(ch);// 把值直接赋值给ch</span><br><span class="line">$ cin.get(ch, len + 1, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">$ char _char[10];               // input: sdsdsdafd</span><br><span class="line">$ cin.get(_char, 10 + 1, <span class="string">&#x27;a&#x27;</span>);  // _char = <span class="string">&quot;sdsdsd&quot;</span>，之后光标停留在 <span class="string">&#x27;a&#x27;</span> 处</span><br><span class="line"></span><br><span class="line">$ cin.ignore()</span><br><span class="line">$ cin.ignore(a, ch)</span><br><span class="line">//如果忽略计数值达到 a 或者被抛弃的字符是 ch ，则cin.ignore() 函数执行终止；</span><br></pre></td></tr></table></figure>


<h3 id="cin-getline"><a href="#cin-getline" class="headerlink" title="cin.getline():"></a>cin.getline():</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ char char[20]; </span><br><span class="line">$ cin.getline(char, len + 1, <span class="string">&#x27;a&#x27;</span>);//+1是为了末尾的<span class="string">&#x27;\0&#x27;</span></span><br><span class="line">$ cin.getline(char, len + 1);//第三个参数系统默认为<span class="string">&#x27;\0&#x27;</span> </span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">char char[10];              // input: sdsdsdafd</span><br><span class="line">cin.getline(char, 10, <span class="string">&#x27;a&#x27;</span>); // char = <span class="string">&quot;sdsdsd&quot;</span>，之后光标停留在 <span class="string">&#x27;f&#x27;</span>处。</span><br><span class="line"></span><br><span class="line">string _string;</span><br><span class="line">getline(cin, _string);//会删除回车符，get()回车会留在缓存区里面</span><br><span class="line">getline(cin, _string, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>





<h3 id="单行多项数据"><a href="#单行多项数据" class="headerlink" title="单行多项数据"></a>单行多项数据</h3><p><label style="color:red">分隔符为空白符</label></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ string temp;</span><br><span class="line">$ getline(cin, temp);</span><br><span class="line">$ istringstream is(temp);</span><br><span class="line">$ vector&lt;string&gt; _v;</span><br><span class="line">$ copy(istream_iterator&lt;string&gt;(is), istream_iterator&lt;string&gt;(), back_inserter(_v));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><label style="color:red">分隔符为空白符，个数未知</label></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">string temp;</span><br><span class="line">getline(cin, temp);</span><br><span class="line">istringstream is(temp); //需要<span class="comment">#include &lt;sstream&gt;</span></span><br><span class="line"></span><br><span class="line">string part;</span><br><span class="line">vector&lt;string&gt; _v;</span><br><span class="line"><span class="keyword">while</span>(is &gt;&gt; part)</span><br><span class="line">&#123;</span><br><span class="line">	_v.push_back(part);</span><br><span class="line">	cout &lt;&lt; part &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><label style="color:red">分隔符不为空白符，个数未知</label></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">string temp;</span><br><span class="line">getline(cin, temp);</span><br><span class="line">istringstream is(temp);</span><br><span class="line"></span><br><span class="line">string part;</span><br><span class="line">vector&lt;string&gt; result;</span><br><span class="line"><span class="keyword">while</span>(getline(is, part, <span class="string">&#x27;;&#x27;</span>))//getline会跳过<span class="string">&#x27;;&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    result.push_back(part);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="多行多项数据"><a href="#多行多项数据" class="headerlink" title="多行多项数据"></a>多行多项数据</h3><p><label style="color:red">Eg1:</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* </span><br><span class="line">	input: </span><br><span class="line">   	[1,2,3,4,5,6]</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; result;</span><br><span class="line">string temp;</span><br><span class="line">cin.get();&#x2F;&#x2F;去除第一个&#39;[&#39;；</span><br><span class="line">getline(cin, temp, &#39;]&#39;);</span><br><span class="line"></span><br><span class="line">istringstream is(temp);</span><br><span class="line">string part;</span><br><span class="line">while(getline(is, part, &#39;,&#39;))</span><br><span class="line">&#123;</span><br><span class="line">    result.push_back(stoi(part));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><label style="color:red">Eg2:</label></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">	input:</span><br><span class="line">	3</span><br><span class="line">    1,10;32,45</span><br><span class="line">    78,94;5,16</span><br><span class="line">    80,100;200,220;16,32</span><br><span class="line">*/</span><br><span class="line">    int m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    cin.get();//去除换行</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;int, int&gt; &gt; result;</span><br><span class="line">    <span class="keyword">for</span>(int _m = 0; _m &lt; m; ++_m)</span><br><span class="line">    &#123;</span><br><span class="line">        string total;</span><br><span class="line">        string part;</span><br><span class="line">        getline(cin, total);//读一行</span><br><span class="line">        istringstream is1(total);</span><br><span class="line">        <span class="keyword">while</span>(getline(is1, part, <span class="string">&#x27;;&#x27;</span>))//根据<span class="string">&#x27;;&#x27;</span>进行分割</span><br><span class="line">        &#123;</span><br><span class="line">            istringstream is2(part);</span><br><span class="line">            string s1;</span><br><span class="line">            string s2;</span><br><span class="line">            getline(is2, s1, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            getline(is2, s2);</span><br><span class="line">            result.push_back(&#123;stoi(s1), stoi(s2)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><label style="color:red">Eg3:</label></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    输入描述：第一行两个数，第一个数字表示用户的数目，第二个数字表示需要判断的用户序号。</span><br><span class="line">    第2 至 N+1 行表示序号为0到N-1的每个用户的朋友的序列列表。</span><br><span class="line">    例如：</span><br><span class="line">    input</span><br><span class="line">    5 0</span><br><span class="line">    1 2 3</span><br><span class="line">    0 4</span><br><span class="line">    0 4</span><br><span class="line">    0 4</span><br><span class="line">    1 2 3</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int N = 0;</span><br><span class="line">int m = 0;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; m;</span><br><span class="line">cin.get();//去除换行符</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt; &gt; result(N);</span><br><span class="line"><span class="keyword">for</span>(int _n = 0; _n &lt; N; ++_n)</span><br><span class="line">&#123;</span><br><span class="line">    string temp;</span><br><span class="line">    getline(cin, temp);</span><br><span class="line">    istringstream is(temp);</span><br><span class="line">    copy(istream_iterator&lt;int&gt;(is), istream_iterator&lt;int&gt;(), back_inserter(result[_n]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++笔记</category>
      </categories>
  </entry>
  <entry>
    <title>BFS与DFS</title>
    <url>/2020/07/24/BFS%E4%B8%8EDFS/</url>
    <content><![CDATA[<h4 id="BFS与DFS"><a href="#BFS与DFS" class="headerlink" title="BFS与DFS"></a>BFS与DFS</h4><p>**DFS:**使用栈保存未被检测的结点，结点按照深度优先的次序被访问并依次被压入栈中，并以相反的次序出栈进行新的检测。</p>
<p>类似树的先序遍历</p>
<p>深搜例子:走迷宫,你没有办法用分身术站在每个走过的位置.不撞南墙不回头.</p>
<p>**BFS:**使用队列保存未被检测的结点。结点按照宽度优先的次序被访问和进出队列。</p>
<p>类似树的按层次遍历的过程</p>
<p>广搜例子:你的眼镜掉在地上以后,你趴在地板上找.你总是先摸最接近你的地方,如果没有,再摸远一点的地方…</p>
<h4 id="DFS模板框架与例子"><a href="#DFS模板框架与例子" class="headerlink" title="DFS模板框架与例子"></a>DFS模板框架与例子</h4><p><strong>DFS:模板</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool vis[maxn][maxn]; &#x2F;&#x2F; 访问标记</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; dxy &#x3D; &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;&#x2F;&#x2F;方向矩阵</span><br><span class="line">bool dfs(参数,i,j)</span><br><span class="line">&#123;</span><br><span class="line">	if(不满足或者不符合) return false;</span><br><span class="line">	if(搜到了或者达到条件)</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F;计数或进行其他操作;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">        vis[i][j]&#x3D;true;&#x2F;&#x2F;标记已经搜索过的节点</span><br><span class="line">        </span><br><span class="line">	for(auto xy:dxy)&#x2F;&#x2F;查找当前点的周围的点</span><br><span class="line">	&#123;</span><br><span class="line">        	int x &#x3D; xy[0] + i;</span><br><span class="line">        	int y &#x3D; xy[1] + j;</span><br><span class="line">	   	if(边界判断和访问标记判断) continue;</span><br><span class="line">         	else</span><br><span class="line">		    if(dfs(进一步深搜)) return true;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">        vis[i][j]&#x3D;false;取消标记;</span><br><span class="line">        return false;&#x2F;&#x2F;本次搜索无效;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">     </span><br><span class="line">       &#x2F;&#x2F;dfs参数中的0表示查到word的第几个字符.</span><br><span class="line">        bool main(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word)&#123;</span><br><span class="line">	      for(int i &#x3D; 0;i &lt; rows; i++)&#123;&#x2F;&#x2F;row行</span><br><span class="line">                for(int j &#x3D; 0; j &lt; cols; j++)&#123;&#x2F;&#x2F;cols列</span><br><span class="line">                if(board[i][j] &#x3D;&#x3D; word[0])&#123; </span><br><span class="line">                    if(dfs(board, i, j, word, 0)) return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>DFS:例子</strong></p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],</span><br><span class="line">[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],</span><br><span class="line">[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]]</span><br></pre></td></tr></table></figure>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dxy &#x3D; &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;&#x2F;&#x2F;方向矩阵</span><br><span class="line">    int rows, cols;</span><br><span class="line">    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;bool&gt;&amp; visit, int i, int j, string&amp; word, int idx)&#123;</span><br><span class="line">        if(board[i][j] !&#x3D; word[idx]) return false;&#x2F;&#x2F;不满足条件</span><br><span class="line">       </span><br><span class="line">        idx++;</span><br><span class="line">         if(idx &#x3D;&#x3D; word.size()) return  true;&#x2F;&#x2F;满足条件</span><br><span class="line">         visit[i*cols+j] &#x3D; true;&#x2F;&#x2F;标记已经访问</span><br><span class="line">        for(auto xy : dxy)&#123;&#x2F;&#x2F;查找当前点的周围的点</span><br><span class="line">            int x &#x3D; xy[0] + i;</span><br><span class="line">            int y &#x3D; xy[1] + j;</span><br><span class="line">            if(x &lt; 0 || x &gt;&#x3D; rows || y &lt; 0 || y &gt;&#x3D; cols || visit[x*cols+y]) continue;&#x2F;&#x2F;边界判断和访问标记判断</span><br><span class="line">            else&#123;</span><br><span class="line">                if(dfs(board, visit, x, y, word, idx)) return true;&#x2F;&#x2F;进一步深搜</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i*cols+j] &#x3D; false;&#x2F;&#x2F;取消标记</span><br><span class="line">       </span><br><span class="line">        return false;&#x2F;&#x2F;本次搜索无效;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;</span><br><span class="line">        if(word &#x3D;&#x3D; &quot;&quot;)  return false;</span><br><span class="line">        rows &#x3D; board.size();</span><br><span class="line">        cols &#x3D; board[0].size();</span><br><span class="line">        vector&lt;bool&gt; visit(rows * cols, false);&#x2F;&#x2F;标记矩阵</span><br><span class="line">        for(int i &#x3D; 0;i &lt; rows; i++)&#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; cols; j++)&#123;</span><br><span class="line">                if(board[i][j] &#x3D;&#x3D; word[0])&#123;</span><br><span class="line">                    if(dfs(board, visit, i, j, word, 0)) return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="BFS模板框架与例子"><a href="#BFS模板框架与例子" class="headerlink" title="BFS模板框架与例子"></a>BFS模板框架与例子</h4><p><strong>BFS:模板</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void bfs(起始点)</span><br><span class="line">&#123;</span><br><span class="line">	将起始点放入队列中;</span><br><span class="line">	标记起点已访问;</span><br><span class="line">    </span><br><span class="line">	while(队列不为空)</span><br><span class="line">	&#123;</span><br><span class="line">		访问队列中首元素x;</span><br><span class="line">      ...一些操作</span><br><span class="line">		删除队首元素;</span><br><span class="line">		for(x所有相邻点)</span><br><span class="line">		&#123;</span><br><span class="line">			if(该点未被访问过且合法)</span><br><span class="line">				将该点加入队列末尾;</span><br><span class="line">                 		标记该点已访问</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	队列为空，广搜结束; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>BFS:例子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打印指定点附近相同值的点的坐标</span><br><span class="line">bool vis[maxn][maxn]; &#x2F;&#x2F; 访问标记</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; dxy &#x3D; &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;&#x2F;&#x2F;方向矩阵</span><br><span class="line">board[5][5];&#x2F;&#x2F;矩阵内容1和0</span><br><span class="line">bfs()&#123;</span><br><span class="line">	int val&#x3D;board[i][j];&#x2F;&#x2F;i,j为初始点坐标</span><br><span class="line">	queue&lt;pair&lt;int,int&gt;&gt; q;</span><br><span class="line">  	q.push(make_pair(i,j));</span><br><span class="line">   	vis[i][j]&#x3D;true;&#x2F;&#x2F;标记</span><br><span class="line">   </span><br><span class="line">      while(!q.empty)&#123;</span><br><span class="line">        pair&lt;int,int&gt; tmp&#x3D;q.front();&#x2F;&#x2F;取出</span><br><span class="line">        q.pop();</span><br><span class="line">        cout&lt;&lt;tmp.first&lt;&lt;tmp.second&lt;&lt;endl;&#x2F;&#x2F;一些操作</span><br><span class="line">        </span><br><span class="line">        for(auto xy: dxy)&#123;</span><br><span class="line">        	int x&#x3D;tmp.first+xy[0];</span><br><span class="line">          	int y&#x3D;tmp.second+xy[1];</span><br><span class="line">          	if(x&gt;&#x3D;0 &amp;&amp; x&lt;5 &amp;&amp; y&gt;&#x3D;0 &amp;&amp; y&lt;5 &amp;&amp; vis[x][y]!&#x3D;true &amp;&amp; board[x][y]&#x3D;&#x3D;val)&#123;</span><br><span class="line">            		q.push(make_pair(x,y));&#x2F;&#x2F;广搜符合条件放进队列</span><br><span class="line">            		vis[x][y]&#x3D;true; &#x2F;&#x2F;标记已经访问</span><br><span class="line">            &#125;    		</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>BFS:例子</strong><br>现在一个紧急的任务是打开一个密码锁。 密码由四位数字组成，每个数字从1到9进行编码。每次可以对任何一位数字加1或减1。当将9加1时，数字将变为1，当将1减1时，数字将变为9.你也可以交换相邻数字，每一个行动记作异步。现在你的任务是使用最小的步骤来打开锁。注意：最左边的数字不与最右边的数字相邻。</p>
<p>输入：<br>第一行输入四个数字，表示密码锁的初始状态。<br>第二行输入四个数字，表示开锁的密码。</p>
<p>输出：<br>最小步数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int num[4],step;&#x2F;&#x2F;num存的密码,step是到这一步的步数</span><br><span class="line">&#125;first,last;</span><br><span class="line">int vis[11][11][11][11];&#x2F;&#x2F;访问标记</span><br><span class="line">void bfs()</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	node a,next;</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	a&#x3D;first;</span><br><span class="line">	a.step&#x3D;0;</span><br><span class="line">	q.push(a);&#x2F;&#x2F;初始点</span><br><span class="line">	memset(vis,0,sizeof(vis));</span><br><span class="line">	vis[a.num[0]][a.num[1]][a.num[2]][a.num[3]]&#x3D;1;&#x2F;&#x2F;标记已经访问</span><br><span class="line">	while(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		a&#x3D;q.front();&#x2F;&#x2F;取出访问</span><br><span class="line">		q.pop();</span><br><span class="line">		if(a.num[0]&#x3D;&#x3D;last.num[0]&amp;&amp;a.num[1]&#x3D;&#x3D;last.num[1]&amp;&amp;a.num[2]&#x3D;&#x3D;last.num[2]&amp;&amp;a.num[3]&#x3D;&#x3D;last.num[3])&#x2F;&#x2F;一些操作,即判断是否符合要求.</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%d\n&quot;,a.step);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		for(i&#x3D;0;i&lt;4;++i)		&#x2F;&#x2F;+1   周围相邻点合法且未被访问的放入,放入后标记已经访问</span><br><span class="line">		&#123;</span><br><span class="line">			next&#x3D;a;</span><br><span class="line">			++next.num[i];</span><br><span class="line">			if(next.num[i]&#x3D;&#x3D;10)</span><br><span class="line">				next.num[i]&#x3D;1;</span><br><span class="line">			if(!vis[next.num[0]][next.num[1]][next.num[2]][next.num[3]])</span><br><span class="line">			&#123;</span><br><span class="line">				vis[next.num[0]][next.num[1]][next.num[2]][next.num[3]]&#x3D;1;</span><br><span class="line">				++next.step;</span><br><span class="line">				q.push(next);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(i&#x3D;0;i&lt;4;++i)		&#x2F;&#x2F;-1  周围相邻点合法且未被访问的放入,放入后标记已经访问</span><br><span class="line">		&#123;</span><br><span class="line">			next&#x3D;a;</span><br><span class="line">			--next.num[i];</span><br><span class="line">			if(next.num[i]&#x3D;&#x3D;0)</span><br><span class="line">				next.num[i]&#x3D;9;</span><br><span class="line">			if(!vis[next.num[0]][next.num[1]][next.num[2]][next.num[3]])</span><br><span class="line">			&#123;</span><br><span class="line">				vis[next.num[0]][next.num[1]][next.num[2]][next.num[3]]&#x3D;1;</span><br><span class="line">				++next.step;</span><br><span class="line">				q.push(next);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for(i&#x3D;0;i&lt;3;++i)		&#x2F;&#x2F;交换  周围相邻点合法且未被访问的放入,放入后标记已经访问</span><br><span class="line">		&#123;</span><br><span class="line">			next&#x3D;a;</span><br><span class="line">			next.num[i]&#x3D;a.num[i+1];</span><br><span class="line">			next.num[i+1]&#x3D;a.num[i];</span><br><span class="line">			if(!vis[next.num[0]][next.num[1]][next.num[2]][next.num[3]])</span><br><span class="line">			&#123;</span><br><span class="line">				vis[next.num[0]][next.num[1]][next.num[2]][next.num[3]]&#x3D;1;</span><br><span class="line">				++next.step;</span><br><span class="line">				q.push(next);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i,j;</span><br><span class="line">	for(i&#x3D;0;i&lt;4;++i)</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;first.num[i]);</span><br><span class="line">	for(i&#x3D;0;i&lt;4;++i)</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;last.num[i]);</span><br><span class="line">	bfs();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++笔记</category>
      </categories>
  </entry>
  <entry>
    <title>algorithm算法函数</title>
    <url>/2020/08/18/algorithm/</url>
    <content><![CDATA[<h4 id="sort-start-end-cmp"><a href="#sort-start-end-cmp" class="headerlink" title="sort(start,end,cmp)"></a>sort(start,end,cmp)</h4><p>（1）start表示要排序数组的起始地址；<br>（2）end表示数组结束地址的下一位；<br>（3）cmp用于规定排序的方法，可不填，默认升序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool cmp(int a , int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lower-bound-和upper-bound"><a href="#lower-bound-和upper-bound" class="headerlink" title="lower_bound( )和upper_bound( )"></a>lower_bound( )和upper_bound( )</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在从小到大的排序数组中，</span><br><span class="line"></span><br><span class="line">lower_bound( begin,end,num)：</span><br><span class="line">&#x2F;&#x2F;从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。</span><br><span class="line"></span><br><span class="line">upper_bound( begin,end,num)：</span><br><span class="line">&#x2F;&#x2F;从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">在从大到小的排序数组中，重载lower_bound()和upper_bound()</span><br><span class="line"></span><br><span class="line">lower_bound( begin,end,num,greater&lt;type&gt;() ):</span><br><span class="line">&#x2F;&#x2F;从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。</span><br><span class="line"></span><br><span class="line">upper_bound( begin,end,num,greater&lt;type&gt;() ):</span><br><span class="line">&#x2F;&#x2F;从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;	&#x2F;&#x2F;lower_bound, upper_bound</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int aa[8] &#x3D; &#123; 10, 20, 10, 30, 50, 40, 20, 10 &#125;;</span><br><span class="line">vector&lt;int&gt; nums_40(aa, aa + 8);</span><br><span class="line">sort(nums_40.begin(), nums_40.end()); &#x2F;&#x2F;10 10 10 20 20 30 40 50</span><br><span class="line">vector&lt;int&gt;::iterator it, it1;</span><br><span class="line">it &#x3D; lower_bound(nums_40.begin(), nums_40.end(), 20);</span><br><span class="line">cout &lt;&lt; *it &lt;&lt;endl;	&#x2F;&#x2F;20，此时的it指向第一个20的位置</span><br><span class="line">it1 &#x3D; upper_bound(nums_40.begin(), nums_40.end(), 20);</span><br><span class="line">cout &lt;&lt; *it1 &lt;&lt; endl;	&#x2F;&#x2F;30  不是20，此时的it1指向右侧20的下一个位置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn&#x3D;100000+10;</span><br><span class="line">const int INF&#x3D;2*int(1e9)+10;</span><br><span class="line">#define LL long long</span><br><span class="line">int cmd(int a,int b)&#123;</span><br><span class="line">	return a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int num[6]&#x3D;&#123;1,2,4,7,15,34&#125;; </span><br><span class="line">	sort(num,num+6);                           &#x2F;&#x2F;按从小到大排序 </span><br><span class="line">	int pos1&#x3D;lower_bound(num,num+6,7)-num;    &#x2F;&#x2F;返回数组中第一个大于或等于被查数的值 </span><br><span class="line">	int pos2&#x3D;upper_bound(num,num+6,7)-num;    &#x2F;&#x2F;返回数组中第一个大于被查数的值</span><br><span class="line">	cout&lt;&lt;pos1&lt;&lt;&quot; &quot;&lt;&lt;num[pos1]&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;pos2&lt;&lt;&quot; &quot;&lt;&lt;num[pos2]&lt;&lt;endl;</span><br><span class="line">	sort(num,num+6,cmd);                      &#x2F;&#x2F;按从大到小排序</span><br><span class="line">	int pos3&#x3D;lower_bound(num,num+6,7,greater&lt;int&gt;())-num;  &#x2F;&#x2F;返回数组中第一个小于或等于被查数的值 </span><br><span class="line">	int pos4&#x3D;upper_bound(num,num+6,7,greater&lt;int&gt;())-num;  &#x2F;&#x2F;返回数组中第一个小于被查数的值 </span><br><span class="line">	cout&lt;&lt;pos3&lt;&lt;&quot; &quot;&lt;&lt;num[pos3]&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;pos4&lt;&lt;&quot; &quot;&lt;&lt;num[pos4]&lt;&lt;endl;</span><br><span class="line">	return 0;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="min-element-和max-element"><a href="#min-element-和max-element" class="headerlink" title="min_element()和max_element"></a>min_element()和max_element</h4><p>max_element(first,end,cmp);其中cmp为可选择参数!返回容器中最小值和最大值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std; </span><br><span class="line">struct node &#123;</span><br><span class="line">   int x, y;</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp1(node a, node b) &#123;</span><br><span class="line">    return a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; v(3);</span><br><span class="line">    int arr[4];</span><br><span class="line">    vector&lt;node&gt; v1(3);</span><br><span class="line">    cout &lt;&lt; *max_element(v.begin(), v.end());</span><br><span class="line">    cout &lt;&lt; *min_element(arr, arr + 4);</span><br><span class="line">    cout &lt;&lt; (*max_element(v1.begin(), v1.end(), cmp1)).y;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p>reverse(it,it2)可以将数组指针在 [it,it2)之间的元素或者容器的迭代器在[it,it2)范围内进行元素反转。</p>
<p><strong>对于数组中的元素</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a[5]&#x3D;&#123;1,3,2,3,4&#125;;</span><br><span class="line">    reverse(a,a+4);&#x2F;&#x2F;将a[0]~a[3]逆转</span><br><span class="line">    for(int i&#x3D;0;i&lt;5;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*(a+i)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>对于容器中元素</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   string s&#x3D;&quot;abcdefghig&quot;;</span><br><span class="line">   reverse(s.begin(),s.end());</span><br><span class="line">   cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>































]]></content>
      <categories>
        <category>C++笔记</category>
      </categories>
  </entry>
  <entry>
    <title>各种排序时间复杂度对比</title>
    <url>/2020/08/12/Untitled/</url>
    <content><![CDATA[<p><img src="/img/25.png"></p>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
  </entry>
  <entry>
    <title>deque(双头队列)</title>
    <url>/2020/08/16/deque/</url>
    <content><![CDATA[<h4 id="deque初始化"><a href="#deque初始化" class="headerlink" title="deque初始化"></a>deque初始化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deque&lt;int&gt; a; &#x2F;&#x2F; 定义一个int类型的双端队列a</span><br><span class="line">deque&lt;int&gt; a(10); &#x2F;&#x2F; 定义一个int类型的双端队列a，并设置初始大小为10</span><br><span class="line">deque&lt;int&gt; a(10, 1); &#x2F;&#x2F; 定义一个int类型的双端队列a，并设置初始大小为10且初始值都为1</span><br><span class="line">deque&lt;int&gt; b(a); &#x2F;&#x2F; 定义并用双端队列a初始化双端队列b</span><br><span class="line">deque&lt;int&gt; b(a.begin(), a.begin()+3); &#x2F;&#x2F; 将双端队列a中从第0个到第2个(共3个)作为双端队列b的初始值</span><br></pre></td></tr></table></figure>
<p>除此之外，还可以直接使用数组来初始化向量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int n[] &#x3D; &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">&#x2F;&#x2F; 将数组n的前5个元素作为双端队列a的初值</span><br><span class="line">&#x2F;&#x2F; 说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，</span><br><span class="line">&#x2F;&#x2F; 这个主要是为了和deque.end()指针统一。</span><br><span class="line">deque&lt;int&gt; a(n, n + 5); </span><br><span class="line">deque&lt;int&gt; a(&amp;n[1], &amp;n[4]); &#x2F;&#x2F; 将n[1]、n[2]、n[3]作为双端队列a的初值</span><br></pre></td></tr></table></figure>
<h4 id="基本操作函数"><a href="#基本操作函数" class="headerlink" title="基本操作函数"></a>基本操作函数</h4><p><label style="color:red"> 容量函数</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">容器大小：deq.size();</span><br><span class="line">容器最大容量：deq.max_size();</span><br><span class="line">更改容器大小：deq.resize();</span><br><span class="line">容器判空：deq.empty();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	deque&lt;int&gt; deq;</span><br><span class="line">	for (int i &#x3D; 0; i&lt;6; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		deq.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; deq.size() &lt;&lt; endl; &#x2F;&#x2F; 输出：6</span><br><span class="line">	cout &lt;&lt; deq.max_size() &lt;&lt; endl; &#x2F;&#x2F; 输出：1073741823</span><br><span class="line">	deq.resize(0); &#x2F;&#x2F; 更改容器大小</span><br><span class="line">	cout &lt;&lt; deq.size() &lt;&lt; endl; &#x2F;&#x2F; 输出：0</span><br><span class="line">	if (deq.empty())</span><br><span class="line">		cout &lt;&lt; &quot;元素为空&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出：元素为空</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><label style="color:red"> 添加函数</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">头部添加元素：deq.push_front(const T&amp; x);</span><br><span class="line">末尾添加元素：deq.push_back(const T&amp; x);</span><br><span class="line">任意位置插入一个元素：deq.insert(iterator it, const T&amp; x);</span><br><span class="line">任意位置插入 n 个相同元素：deq.insert(iterator it, int n, const T&amp; x);</span><br><span class="line">插入另一个向量的 [forst,last) 间的数据：deq.insert(iterator it, iterator first, iterator last);</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	deque&lt;int&gt; deq;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 头部增加元素</span><br><span class="line">	deq.push_front(4);</span><br><span class="line">	&#x2F;&#x2F; 末尾添加元素</span><br><span class="line">	deq.push_back(5);</span><br><span class="line">	&#x2F;&#x2F; 任意位置插入一个元素</span><br><span class="line">	deque&lt;int&gt;::iterator it &#x3D; deq.begin();</span><br><span class="line">	deq.insert(it, 2);</span><br><span class="line">	&#x2F;&#x2F; 任意位置插入n个相同元素</span><br><span class="line">	it &#x3D; deq.begin(); &#x2F;&#x2F; 必须要有这句</span><br><span class="line">	deq.insert(it, 3, 9);</span><br><span class="line">	&#x2F;&#x2F; 插入另一个向量的[forst,last]间的数据</span><br><span class="line">	deque&lt;int&gt; deq2(5,8);</span><br><span class="line">	it &#x3D; deq.begin(); &#x2F;&#x2F; 必须要有这句</span><br><span class="line">	deq.insert(it, deq2.end() - 1, deq2.end());</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 遍历显示</span><br><span class="line">	for (it &#x3D; deq.begin(); it !&#x3D; deq.end(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#x2F;&#x2F; 输出：8 9 9 9 2 4 5</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><label style="color:red"> 删除函数</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">头部删除元素：deq.pop_front();</span><br><span class="line">末尾删除元素：deq.pop_back();</span><br><span class="line">任意位置删除一个元素：deq.erase(iterator it);</span><br><span class="line">删除 [first,last)之间的元素：deq.erase(iterator first, iterator last);</span><br><span class="line">清空所有元素：deq.clear();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	deque&lt;int&gt; deq;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 8; i++)</span><br><span class="line">		deq.push_back(i);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 头部删除元素</span><br><span class="line">	deq.pop_front();</span><br><span class="line">	&#x2F;&#x2F; 末尾删除元素</span><br><span class="line">	deq.pop_back();</span><br><span class="line">	&#x2F;&#x2F; 任意位置删除一个元素</span><br><span class="line">	deque&lt;int&gt;::iterator it &#x3D; deq.begin();</span><br><span class="line">	deq.erase(it);</span><br><span class="line">	&#x2F;&#x2F; 删除[first,last]之间的元素</span><br><span class="line">	deq.erase(deq.begin(), deq.begin()+1);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 遍历显示</span><br><span class="line">	for (it &#x3D; deq.begin(); it !&#x3D; deq.end(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; &quot; &quot;;&#x2F;&#x2F; 输出：3 4 5 6</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 清空所有元素</span><br><span class="line">	deq.clear();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><label style="color:red"> 访问函数</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下标访问：deq[1]; &#x2F;&#x2F; 并不会检查是否越界</span><br><span class="line">at 方法访问：deq.at(1); &#x2F;&#x2F; 以上两者的区别就是 at 会检查是否越界，是则抛出 out of range 异常</span><br><span class="line">访问第一个元素：deq.front();</span><br><span class="line">访问最后一个元素：deq.back();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	deque&lt;int&gt; deq;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 6; i++)</span><br><span class="line">		deq.push_back(i);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 下标访问</span><br><span class="line">	cout &lt;&lt; deq[0] &lt;&lt; endl; &#x2F;&#x2F; 输出：0</span><br><span class="line">	&#x2F;&#x2F; at方法访问</span><br><span class="line">	cout &lt;&lt; deq.at(0) &lt;&lt; endl; &#x2F;&#x2F; 输出：0</span><br><span class="line">	&#x2F;&#x2F; 访问第一个元素</span><br><span class="line">	cout &lt;&lt; deq.front() &lt;&lt; endl; &#x2F;&#x2F; 输出：0</span><br><span class="line">	&#x2F;&#x2F; 访问最后一个元素</span><br><span class="line">	cout &lt;&lt; deq.back() &lt;&lt; endl; &#x2F;&#x2F; 输出：5</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><label style="color:red"> 其他函数</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多个元素赋值：deq.assign(int nSize, const T&amp; x); &#x2F;&#x2F; 类似于初始化时用数组进行赋值</span><br><span class="line">交换两个同类型容器的元素：swap(deque&amp;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 多个元素赋值</span><br><span class="line">	deque&lt;int&gt; deq;</span><br><span class="line">	deq.assign(3, 1);</span><br><span class="line">	deque&lt;int&gt; deq2;</span><br><span class="line">	deq2.assign(3, 2);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 交换两个容器的元素</span><br><span class="line">	deq.swap(deq2);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 遍历显示</span><br><span class="line">	cout &lt;&lt; &quot;deq: &quot;;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; deq.size(); i++)</span><br><span class="line">		cout &lt;&lt; deq[i] &lt;&lt; &quot; &quot;; &#x2F;&#x2F; 输出：2 2 2</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 遍历显示</span><br><span class="line">	cout &lt;&lt; &quot;deq2: &quot;;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; deq2.size(); i++)</span><br><span class="line">		cout &lt;&lt; deq2[i] &lt;&lt; &quot; &quot;; &#x2F;&#x2F; 输出：1 1 1</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代器与算法"><a href="#迭代器与算法" class="headerlink" title="迭代器与算法"></a>迭代器与算法</h4><p><label style="color:red"> 迭代器</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开始迭代器指针：deq.begin();，iterator</span><br><span class="line">末尾迭代器指针：deq.end(); &#x2F;&#x2F; 指向最后一个元素的下一个位置</span><br><span class="line">指向常量的开始迭代器指针：deq.cbegin(); &#x2F;&#x2F; 意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。</span><br><span class="line">指向常量的末尾迭代器指针：deq.cend();</span><br><span class="line">反向迭代器指针，指向最后一个元素：deq.rbegin();，reverse_iterator</span><br><span class="line">反向迭代器指针，指向第一个元素的前一个元素：deq.rend();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	deque&lt;int&gt; deq;</span><br><span class="line">	deq.push_back(1);</span><br><span class="line">	deq.push_back(2);</span><br><span class="line">	deq.push_back(3);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *(deq.begin()) &lt;&lt; endl; &#x2F;&#x2F; 输出：1</span><br><span class="line">	cout &lt;&lt; *(--deq.end()) &lt;&lt; endl; &#x2F;&#x2F; 输出：3</span><br><span class="line">	cout &lt;&lt; *(deq.cbegin()) &lt;&lt; endl; &#x2F;&#x2F; 输出：1</span><br><span class="line">	cout &lt;&lt; *(--deq.cend()) &lt;&lt; endl; &#x2F;&#x2F; 输出：3</span><br><span class="line">	cout &lt;&lt; *(deq.rbegin()) &lt;&lt; endl; &#x2F;&#x2F; 输出：3</span><br><span class="line">	cout &lt;&lt; *(--deq.rend()) &lt;&lt; endl; &#x2F;&#x2F; 输出：1</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><label style="color:red"> 算法</label></p>
<p>遍历元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deque&lt;int&gt;::iterator it;</span><br><span class="line">for (it &#x3D; deq.begin(); it !&#x3D; deq.end(); it++)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">for (int i &#x3D; 0; i &lt; deq.size(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; deq.at(i) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>元素翻转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">reverse(deq.begin(), deq.end());</span><br></pre></td></tr></table></figure>
<p>元素排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">sort(deq.begin(), deq.end()); &#x2F;&#x2F; 采用的是从小到大的排序</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果想从大到小排序，可以采用先排序后反转的方式，也可以采用下面方法:</span><br><span class="line">&#x2F;&#x2F; 自定义从大到小的比较器，用来改变排序方式</span><br><span class="line">bool Comp(const int&amp; a, const int&amp; b) &#123;</span><br><span class="line">    return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(deq.begin(), deq.end(), Comp);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>STL容器</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/21/hello-world/</url>
    <content><![CDATA[<h3 id="更新博客代码顺序"><a href="#更新博客代码顺序" class="headerlink" title="更新博客代码顺序"></a>更新博客代码顺序</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean [清理]</span><br><span class="line">$ hexo generate [部署]</span><br><span class="line">$ hexo deploy [展示]</span><br><span class="line">$ hexo server [本地预览]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;font size&#x3D;4&gt;&lt;&#x2F;font&gt;    &#x2F;&#x2F;设置字体大小</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;label style&#x3D;&quot;color:red&quot;&gt; &lt;&#x2F;label&gt;</span><br></pre></td></tr></table></figure>
<p><label style="color:red">参考地址：<a href="https://handsomesuperred.github.io/archives/"></label><br>https://handsomesuperred.github.io/archives/</a><br><label style="color:red"> </label></p>
]]></content>
  </entry>
  <entry>
    <title>jpeglib压缩</title>
    <url>/2020/07/23/jpeglib%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fstream&gt;</span></span><br><span class="line">extern <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#include &quot;jpeglib.h&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int rgb2jpeg(unsigned char* rgb_buffer, int width, int height,int depth ,int quality, unsigned char* jpeg_buffer, unsigned long&amp; jpeg_size)</span><br><span class="line">&#123;</span><br><span class="line">//    unsigned char *pTempDst = new unsigned char[width * abs(height) * depth / 8];</span><br><span class="line">//   // Bgra2Rgb(rgb_buffer, width, height, depth / 8, rgb);</span><br><span class="line">//    //unsigned char* pTempDst = rgb;</span><br><span class="line">//    <span class="keyword">for</span> (int i = 0; i &lt; abs(height); i++)</span><br><span class="line">//    &#123;</span><br><span class="line">//        const unsigned char* pTempSrc = nullptr;</span><br><span class="line">//        <span class="keyword">if</span> (height &gt; 0)</span><br><span class="line">//        &#123;</span><br><span class="line">//            pTempSrc = rgb_buffer + width * i *(depth / 8) ;</span><br><span class="line">//        &#125;</span><br><span class="line">//        <span class="keyword">else</span></span><br><span class="line">//        &#123;</span><br><span class="line">//            pTempSrc = rgb_buffer + width * abs(i + height + 1) * (depth / 8);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">//        <span class="keyword">for</span> (int j = 0; j &lt; width; j++)</span><br><span class="line">//        &#123;</span><br><span class="line">//            *(pTempDst) = *(pTempSrc + 2);</span><br><span class="line">//            *(pTempDst + 1) = *(pTempSrc + 1);</span><br><span class="line">//            *(pTempDst + 2) = *(pTempSrc);</span><br><span class="line">//            pTempDst += 3;</span><br><span class="line">//            pTempSrc += (depth / 8);</span><br><span class="line">//        &#125;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    //pTempDst新的rgb</span><br><span class="line">    //rgb_buffer旧的rgb</span><br><span class="line"></span><br><span class="line">    //压缩</span><br><span class="line">    unsigned char* outbuffer;</span><br><span class="line">    outbuffer=NULL;</span><br><span class="line"></span><br><span class="line">    struct jpeg_compress_struct cinfo;</span><br><span class="line">    struct jpeg_error_mgr jerr;</span><br><span class="line">    cinfo.err=jpeg_std_error(&amp;jerr);</span><br><span class="line">    jpeg_create_compress(&amp;cinfo);</span><br><span class="line"></span><br><span class="line">    jpeg_mem_dest(&amp;cinfo,&amp;outbuffer,&amp;jpeg_size);</span><br><span class="line"></span><br><span class="line">    cinfo.image_width=width;</span><br><span class="line">    cinfo.image_height=height;</span><br><span class="line">    cinfo.input_components=1;//channels;//3   1</span><br><span class="line">    cinfo.in_color_space=JCS_GRAYSCALE;//JCS_GRAYSCALE;//JCS_RGB</span><br><span class="line"></span><br><span class="line">    jpeg_set_defaults(&amp;cinfo);</span><br><span class="line">    cinfo.dct_method=JDCT_FASTEST;</span><br><span class="line">    jpeg_set_quality(&amp;cinfo, quality, TRUE /* <span class="built_in">limit</span> to baseline-JPEG values */);</span><br><span class="line"></span><br><span class="line">    jpeg_start_compress(&amp;cinfo,TRUE);</span><br><span class="line"></span><br><span class="line">    //JSAMPROW row_pointer[1];        /* pointer to JSAMPLE row[s] */</span><br><span class="line">    JSAMPROW row_pointer[height];</span><br><span class="line"></span><br><span class="line">    int     row_stride;             /* physical row width <span class="keyword">in</span> image buffer */</span><br><span class="line">    row_stride = width * depth/8; /* JSAMPLEs per row <span class="keyword">in</span> image_buffer */</span><br><span class="line">    //========压缩方式一</span><br><span class="line">    int i=0;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;height)</span><br><span class="line">    &#123;</span><br><span class="line">         row_pointer[i]=&amp;rgb_buffer[i*row_stride];</span><br><span class="line">        i++;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">float</span> start = getTickCount();</span><br><span class="line">     (void)jpeg_write_scanlines(&amp;cinfo,row_pointer,height);</span><br><span class="line">        <span class="built_in">float</span> end = getTickCount();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span> last = end-start;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;time consume: &quot;</span> &lt;&lt; (last / getTickFrequency() * 1000) &lt;&lt; endl;</span><br><span class="line">    //=======压缩方式二</span><br><span class="line">//    <span class="keyword">while</span>(cinfo.next_scanline&lt;cinfo.image_height)</span><br><span class="line">//   &#123;</span><br><span class="line">//     row_pointer[0]=&amp;rgb_buffer[cinfo.next_scanline*row_stride];</span><br><span class="line"></span><br><span class="line">//     (void)jpeg_write_scanlines(&amp;cinfo,row_pointer,1);</span><br><span class="line">//   &#125;</span><br><span class="line">    //======</span><br><span class="line"></span><br><span class="line">   jpeg_finish_compress(&amp;cinfo);</span><br><span class="line">   <span class="keyword">for</span>(int i=0;i&lt;jpeg_size;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       jpeg_buffer[i]=outbuffer[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(NULL!=outbuffer)</span><br><span class="line">   &#123;</span><br><span class="line">       free(outbuffer);</span><br><span class="line">       outbuffer=NULL;</span><br><span class="line">   &#125;</span><br><span class="line">   jpeg_destroy_compress(&amp;cinfo);</span><br><span class="line">   <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    int  width=4024;</span><br><span class="line">    int height=3036;</span><br><span class="line">    int depth=8;</span><br><span class="line">    unsigned char *kk = new unsigned char[width * abs(height) * depth / 8];</span><br><span class="line">    unsigned long imgsize;</span><br><span class="line">    Mat input_image=imread(<span class="string">&quot;11.bmp&quot;</span>,0);</span><br><span class="line">    unsigned char *brga=input_image.data;</span><br><span class="line">    int quality=1;</span><br><span class="line">  </span><br><span class="line">    rgb2jpeg(brga,  width,  height, depth , quality,  kk,  imgsize);</span><br><span class="line">    </span><br><span class="line">	  //brga:原图，width:原图宽，height:原图高</span><br><span class="line">     //depth:图像深度，灰度:8,彩图:24</span><br><span class="line">     //kk:压缩后的图片，imgsize:压缩后的图像大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">struct my_error_mgr &#123;</span><br><span class="line">	struct jpeg_error_mgr pub;  /* <span class="string">&quot;public&quot;</span> fields */</span><br><span class="line">	jmp_buf setjmp_buffer;    /* <span class="keyword">for</span> <span class="built_in">return</span> to <span class="built_in">caller</span> */</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct my_error_mgr * my_error_ptr;</span><br><span class="line"></span><br><span class="line">void my_error_exit(j_common_ptr cinfo)</span><br><span class="line">&#123;</span><br><span class="line">	my_error_ptr myerr = (my_error_ptr)cinfo-&gt;err;</span><br><span class="line">	(*cinfo-&gt;err-&gt;output_message) (cinfo);</span><br><span class="line">	longjmp(myerr-&gt;setjmp_buffer, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int jpeg2rgb(unsigned char* jpeg_buffer, int jpeg_size, unsigned char* rgb_buffer, int* size, int* width, int* height)</span><br><span class="line">&#123;</span><br><span class="line">	struct jpeg_decompress_struct cinfo;</span><br><span class="line">	struct my_error_mgr jerr;</span><br><span class="line"></span><br><span class="line">	JSAMPARRAY buffer;</span><br><span class="line">	int row_stride = 0;</span><br><span class="line">	unsigned char* tmp_buffer = NULL;</span><br><span class="line">	int rgb_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (jpeg_buffer == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;no jpeg buffer here.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rgb_buffer == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;you need to alloc rgb buffer.\n&quot;</span>);</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cinfo.err = jpeg_std_error(&amp;jerr.pub);</span><br><span class="line">	jerr.pub.error_exit = my_error_exit;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (setjmp(jerr.setjmp_buffer))</span><br><span class="line">	&#123;</span><br><span class="line">		jpeg_destroy_decompress(&amp;cinfo);</span><br><span class="line">		<span class="built_in">return</span> -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jpeg_create_decompress(&amp;cinfo);</span><br><span class="line">	jpeg_mem_src(&amp;cinfo, jpeg_buffer, jpeg_size);</span><br><span class="line">	jpeg_read_header(&amp;cinfo, TRUE);</span><br><span class="line">	//cinfo.out_color_space = JCS_RGB; //JCS_YCbCr;  // 设置输出格式</span><br><span class="line">	jpeg_start_decompress(&amp;cinfo);</span><br><span class="line"></span><br><span class="line">	row_stride = cinfo.output_width * cinfo.output_components;</span><br><span class="line">	*width = cinfo.output_width;</span><br><span class="line">	*height = cinfo.output_height;</span><br><span class="line"></span><br><span class="line">	rgb_size = row_stride * cinfo.output_height; // 总大小</span><br><span class="line">	*size = rgb_size;</span><br><span class="line">    </span><br><span class="line">	buffer = (*cinfo.mem-&gt;alloc_sarray)((j_common_ptr)&amp;cinfo, JPOOL_IMAGE, row_stride, 1);</span><br><span class="line">	//===========</span><br><span class="line">	/*<span class="built_in">printf</span>(<span class="string">&quot;debug--:\nrgb_size: %d, size: %d w: %d h: %d row_stride: %d \n&quot;</span>, rgb_size,</span><br><span class="line">		cinfo.image_width*cinfo.image_height * 3,</span><br><span class="line">		cinfo.image_width,</span><br><span class="line">		cinfo.image_height,</span><br><span class="line">		row_stride);*/</span><br><span class="line">	tmp_buffer = rgb_buffer;</span><br><span class="line">	<span class="keyword">while</span> (cinfo.output_scanline &lt; cinfo.output_height) // 解压每一行</span><br><span class="line">	&#123;</span><br><span class="line">		jpeg_read_scanlines(&amp;cinfo, buffer, 1);</span><br><span class="line">		// 复制到内存</span><br><span class="line">		memcpy(tmp_buffer, buffer[0], row_stride);</span><br><span class="line">		tmp_buffer += row_stride;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jpeg_finish_decompress(&amp;cinfo);</span><br><span class="line">	jpeg_destroy_decompress(&amp;cinfo);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">	 char* kk = new  char[4024 * 3036 ];</span><br><span class="line">     </span><br><span class="line">	 unsigned char *rgb = new unsigned char[4024 * 3036 ];</span><br><span class="line">	 int size;</span><br><span class="line">	 int rgb_w;</span><br><span class="line">	 int rgb_h;</span><br><span class="line"></span><br><span class="line">	 jpeg2rgb((unsigned char*)kk, cc, rgb, &amp;size, &amp;rgb_w, &amp;rgb_h);</span><br><span class="line">     //kk:压缩图片 cc:压缩图片大小 </span><br><span class="line">     //rgb:解压后的图片 size:解压后图片大小</span><br><span class="line">     //rgb_w:解压后图片宽</span><br><span class="line">     //rgb_h:解压后图片高</span><br><span class="line">     </span><br><span class="line">      Mat mat(3036, 4024, CV_8UC1, rgb);</span><br><span class="line">	  namedWindow(<span class="string">&quot;11&quot;</span>, WINDOW_NORMAL);</span><br><span class="line">	  resizeWindow(<span class="string">&quot;11&quot;</span>, 1006, 759);</span><br><span class="line">	  imshow(<span class="string">&quot;11&quot;</span>, mat);</span><br><span class="line">	  waitKey();</span><br><span class="line"></span><br><span class="line">	  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>jpeglib压缩</category>
      </categories>
  </entry>
  <entry>
    <title>list(链表)</title>
    <url>/2020/08/17/list/</url>
    <content><![CDATA[<h4 id="list的初始化创建"><a href="#list的初始化创建" class="headerlink" title="list的初始化创建"></a>list的初始化创建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list() 声明一个空列表；</span><br><span class="line">list(n) 声明一个有n个元素的列表，每个元素都是由其默认构造函数T()构造出来的</span><br><span class="line">list(n,val) 声明一个由n个元素的列表，每个元素的值都是val得来的</span><br><span class="line">list(first,last) 声明一个列表，其元素的初始值来源于由区间所指定的序列中的元素</span><br></pre></td></tr></table></figure>

<h4 id="list常用函数"><a href="#list常用函数" class="headerlink" title="list常用函数"></a>list常用函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iterator begin()&#x2F;&#x2F;迭代器</span><br><span class="line">iterator end()</span><br><span class="line">reverse_iterator rbegin()&#x2F;&#x2F;反向迭代器</span><br><span class="line">reverse_iterator rend()</span><br><span class="line"></span><br><span class="line">push_back()  &#x2F;&#x2F;从list的末端插入。</span><br><span class="line">push_front() &#x2F;&#x2F;从list的头部插入。</span><br><span class="line">pop_back() &#x2F;&#x2F;删除最后一个元素。</span><br><span class="line">pop_front() &#x2F;&#x2F;删除第一个元素。</span><br><span class="line">front()	&#x2F;&#x2F;获得list容器中的头部元素。</span><br><span class="line">back()	&#x2F;&#x2F;获得list容器的最后一个元素。</span><br><span class="line">resize()	&#x2F;&#x2F;如果调用resize(n)将list的长度改为只容纳n个元素，超出的元素将被删除。</span><br><span class="line">	&#x2F;&#x2F;如果需要扩展那么调用默认构造函数T()将元素加到list末端。</span><br><span class="line">    &#x2F;&#x2F;如果调用resize(n,val)，则扩展元素要调用构造函数T(val)函数进行元素构造，其余部分相同。</span><br><span class="line"></span><br><span class="line">erase()：删除一个元素或一个区域的元素(两个重载)</span><br><span class="line">	l1.erase(l1.begin()); 	&#x2F;&#x2F;将l1的第一个元素删除。</span><br><span class="line">	l1.erase(l1.begin(),l1.end()); 	&#x2F;&#x2F;将l1的从begin()到end()之间的元素删除。</span><br><span class="line">    </span><br><span class="line">assign()</span><br><span class="line">	l1.assign(n,val)	&#x2F;&#x2F;将 l1中元素变为n个T(val）。</span><br><span class="line">	l1.assign(l2.begin(),l2.end())	&#x2F;&#x2F;将l2中的从l2.begin()到l2.end()之间的数值赋值给l1。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">empty() &#x2F;&#x2F; 判断list是否为空。</span><br><span class="line">clear() &#x2F;&#x2F; 清空list中的所有元素。</span><br><span class="line">size() &#x2F;&#x2F;返回容器中的元素数量</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort()&#x2F;&#x2F;将链表从小到大排序</span><br><span class="line">remove (const T &amp; val) &#x2F;&#x2F;删除和 val 相等的元素</span><br><span class="line">unique() &#x2F;&#x2F;删除所有和前一个元素相等的元素，处理后相邻无重复</span><br><span class="line">merge() &#x2F;&#x2F;合并两个链表并使之默认升序(也可改)。</span><br><span class="line">	&#x2F;&#x2F;l1.merge(l2，greater&lt;int&gt;()); 调用结束后l2变为空，l1中元素包含原来l1 和 l2中的元素，并且排好序，升序。</span><br><span class="line">    </span><br><span class="line">splice(iterator i, list &lt;T&gt; &amp; x, iterator first, iterator last)</span><br><span class="line">	&#x2F;&#x2F;在位置 i 前面插入链表 x 中的区间 [first, last)，并在链表 x 中删除该区间。</span><br><span class="line">	&#x2F;&#x2F;链表自身和链表 x 可以是同一个链表，只要 i 不在 [first, last) 中即可</span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>STL容器</category>
      </categories>
  </entry>
  <entry>
    <title>map、unordered_map、pair</title>
    <url>/2020/08/16/map/</url>
    <content><![CDATA[<h4 id="map与unordered-map区别"><a href="#map与unordered-map区别" class="headerlink" title="map与unordered_map区别"></a>map与unordered_map区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map是有序的，形式为map&lt;typename A, typename B&gt;，map的内部实现默认使用A类型变量的升序来排序map的值。</span><br><span class="line"></span><br><span class="line">unordered_map是无序的。</span><br><span class="line"></span><br><span class="line">map内部是红黑树，在插入元素时会自动排序，</span><br><span class="line">而无序容器unordered_map内部是散列表，通过哈希而不是排序来快速操作元素，使得效率更高。</span><br><span class="line">当你不需要排序时选择unordered_map的效率更高。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h4><p><label style="color:red"> pair类型的定义和初始化</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p; ： 定义了一个空的pair对象p，T1和T2的成员都进行了值初始化</span><br><span class="line">pair&lt;T1, T2&gt; p(v1, v2); ： p是一个成员类型为T1和T2的pair; first和second成员分别用v1和v2进行初始化。</span><br><span class="line">pair&lt;T1, T2&gt; p &#x3D; &#123;v1, v2&#125; ：等价于p(v1, v2)</span><br><span class="line">make_pair(v1, v2) ： 以v1和v2值创建的一个新的pair对象</span><br></pre></td></tr></table></figure>
<p><label style="color:red">pair对象的一些操作</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p.first	返回p的名为 first 的(公有)数据成员</span><br><span class="line">p.second	返回p的名为second的(公有)数据成员</span><br><span class="line">p1 &#x3D;&#x3D; p2	当 first 和 second 成员分别相等时，两个pair相等</span><br><span class="line">p1 !&#x3D; p2	若不能达到以上要求，则不相等</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    pair&lt;int, string&gt; p1(0, &quot;Hello&quot;);</span><br><span class="line">    printf(&quot;%d, %s\n&quot;, p1.first, p1.second.c_str());</span><br><span class="line">    pair&lt;int, string&gt; p2 &#x3D; make_pair(1, &quot;World&quot;);</span><br><span class="line">    printf(&quot;%d, %s\n&quot;, p2.first, p2.second.c_str());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="map基本操作"><a href="#map基本操作" class="headerlink" title="map基本操作"></a>map基本操作</h4><p><label style="color:red">创建map对象</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map&lt;k, v&gt; m;	： 定义了一个名为m的空的map对象</span><br><span class="line">map&lt;k, v&gt; m2(m); ： 创建了m的副本m2</span><br><span class="line">map&lt;k, v&gt; m3(b, e); ： 创建了map对象m3，并且存储迭代器b和e范围内的所有元素的副本</span><br><span class="line"></span><br><span class="line">map&lt;int, char&gt; m; 		&#x2F;&#x2F; 定义了一个名为m的空的map</span><br><span class="line">map&lt;int, char&gt; m2(m); 		&#x2F;&#x2F; 创建了m的副本m2</span><br><span class="line">map&lt;int, char&gt; m3(m.begin(), m.end()); 	&#x2F;&#x2F; 创建了map对象m3，并且存储迭代器范围内的所有元素的副本</span><br></pre></td></tr></table></figure>


<p><label style="color:red">map元素访问</label></p>
<p>使用下标 [ ] 与 at() 方法访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, int&gt; mymap &#x3D; &#123;</span><br><span class="line">        &#123;&quot;alpha&quot;, 0&#125;, &#123;&quot;beta&quot;, 0&#125;, &#123;&quot;gamma&quot;, 0&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    mymap.at(&quot;alpha&quot;) &#x3D; 10;</span><br><span class="line">    mymap.at(&quot;beta&quot;) &#x3D; 20;</span><br><span class="line">    mymap.at(&quot;gamma&quot;) &#x3D; 30;</span><br><span class="line">    </span><br><span class="line">    mymap[&#39;a&#39;] &#x3D; &quot;an element&quot;;</span><br><span class="line">    mymap[&#39;b&#39;] &#x3D; &quot;another element&quot;;</span><br><span class="line">    mymap[&#39;c&#39;] &#x3D; mymap[&#39;b&#39;];</span><br></pre></td></tr></table></figure>


<p><label style="color:red">map中元素的插入</label></p>
<p>在map中元素有两种插入方法：1. 使用下标 [] 2. 使用 insert() 函数</p>
<p>下标访问存在的元素，将会覆盖map容器中的该元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用下标[]插入</span><br><span class="line">使用下标访问不存在的元素，将会在map容器中添加一个新的元素；</span><br><span class="line">使用下标访问存在的元素，将会覆盖map容器中的该元素</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    map&lt;int, char&gt; mymap;</span><br><span class="line">    mymap[0] &#x3D; &#39;a&#39;;</span><br><span class="line">    mymap[1] &#x3D; &#39;b&#39;;</span><br><span class="line">    mymap[2] &#x3D; &#39;c&#39;;</span><br><span class="line">    mymap[0] &#x3D; &#39;x&#39;;</span><br><span class="line">    for (map&lt;int, char&gt;::iterator iter &#x3D; mymap.begin(); iter !&#x3D; mymap.end(); iter++)</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; &#x3D;&#x3D;&gt; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当map中有这个关键字时，insert操作是不能再插入数据的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert函数的插入方法</span><br><span class="line"></span><br><span class="line">pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class="line">&#x2F;&#x2F;插入单个键值对，并返回插入位置和成功标志，插入位置已经存在值时，插入失败</span><br><span class="line"></span><br><span class="line">iterator insert (const_iterator position, const value_type&amp; val);</span><br><span class="line">&#x2F;&#x2F;在指定位置插入，在不同位置插入效率是不一样的，因为涉及到重排</span><br><span class="line"></span><br><span class="line">void insert (InputIterator first, InputIterator last);</span><br><span class="line">&#x2F;&#x2F;插入迭代器范围内键值对</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;char, int&gt; mymap;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; （1）插入单个值</span><br><span class="line">    mymap.insert(std::pair&lt;char, int&gt;(&#39;a&#39;, 100));</span><br><span class="line">    mymap.insert(std::pair&lt;char, int&gt;(&#39;z&#39;, 200));   &#x2F;&#x2F;mymap.insert(map&lt;char, int&gt;::value_type(&#39;z&#39;, 200))</span><br><span class="line">    </span><br><span class="line">    mymap.insert(std::make_pair(&#39;f&#39;, 300));	&#x2F;&#x2F; pair方式和make_pair功能是一样的</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 返回插入位置以及是否插入成功</span><br><span class="line">    std::pair&lt;std::map&lt;char, int&gt;::iterator, bool&gt; ret;</span><br><span class="line">    ret &#x3D; mymap.insert(std::pair&lt;char, int&gt;(&#39;z&#39;, 500));</span><br><span class="line">    if (ret.second &#x3D;&#x3D; false) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;插入失败&quot;;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; （2）指定位置插入</span><br><span class="line">    std::map&lt;char, int&gt;::iterator it &#x3D; mymap.begin();</span><br><span class="line">    mymap.insert(it, std::pair&lt;char, int&gt;(&#39;b&#39;, 300));  &#x2F;&#x2F;效率更高</span><br><span class="line">    mymap.insert(it, std::pair&lt;char, int&gt;(&#39;c&#39;, 400));  &#x2F;&#x2F;效率非最高</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; （3）范围多值插入</span><br><span class="line">    std::map&lt;char, int&gt; anothermap;</span><br><span class="line">    anothermap.insert(mymap.begin(), mymap.find(&#39;c&#39;));</span><br><span class="line">    &#x2F;&#x2F;find若存在，返回指向该key的迭代器。若不存在，则返回迭代器的尾指针，即 mymap.end()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; （4）列表形式插入</span><br><span class="line">    anothermap.insert(&#123; &#123; &#39;d&#39;, 100 &#125;, &#123;&#39;e&#39;, 200&#125; &#125;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><label style="color:red">erase() 删除元素</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_t erase( const key_type&amp; key );</span><br><span class="line">&#x2F;&#x2F;根据key来进行删除， 返回删除的元素数量，在map里结果非0即1</span><br><span class="line"></span><br><span class="line">iterator erase( iterator pos )</span><br><span class="line">&#x2F;&#x2F;删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器</span><br><span class="line"></span><br><span class="line">iterator erase( const_iterator first, const_iterator last );</span><br><span class="line">&#x2F;&#x2F;删除一定范围内的元素，并返回一个指向下一元素的迭代器</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    map&lt;int, int&gt; mymap;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">        mymap.insert(make_pair(i, i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mymap.erase(0);          	 &#x2F;&#x2F; （1）删除key为0的元素</span><br><span class="line">    mymap.erase(mymap.begin());  &#x2F;&#x2F; （2）删除迭代器指向的位置元素</span><br><span class="line">    </span><br><span class="line">    map&lt;int, int&gt;::iterator it;</span><br><span class="line">    for (it &#x3D; mymap.begin(); it !&#x3D; mymap.end(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; &quot;&#x3D;&#x3D;&gt;&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">  	mymap.erase(mapStudent.begin(), mapStudent.end());  &#x2F;&#x2F;用迭代器范围刪除 : 把整个map清空</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><label style="color:red"> find(k) 查找元素</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; find 返回迭代器指向当前查找元素的位置否则返回map::end()位置</span><br><span class="line">iter &#x3D; mapStudent.find(&quot;123&quot;);</span><br><span class="line"> </span><br><span class="line">if(iter !&#x3D; mapStudent.end())</span><br><span class="line">       cout&lt;&lt;&quot;Find, the value is&quot;&lt;&lt;iter-&gt;second&lt;&lt;endl;</span><br><span class="line">else</span><br><span class="line">   cout&lt;&lt;&quot;Do not Find&quot;&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h4 id="map的常用操作函数："><a href="#map的常用操作函数：" class="headerlink" title="map的常用操作函数："></a>map的常用操作函数：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin()         返回指向map头部的迭代器，iterator</span><br><span class="line">       </span><br><span class="line">end()           返回指向map末尾的迭代器</span><br><span class="line"></span><br><span class="line">rbegin()        返回一个指向map尾部的逆向迭代器，reverse_iterator</span><br><span class="line"></span><br><span class="line">rend()          返回一个指向map头部的逆向迭代器</span><br><span class="line"></span><br><span class="line">clear(）        删除所有元素</span><br><span class="line"></span><br><span class="line">empty()         如果map为空则返回true</span><br><span class="line"></span><br><span class="line">size()          返回map中元素的个数 </span><br><span class="line"></span><br><span class="line">max_size()      返回可以容纳的最大元素个数</span><br><span class="line"></span><br><span class="line">insert()        插入元素</span><br><span class="line"></span><br><span class="line">erase()         删除一个元素，根据key或者迭代器</span><br><span class="line"></span><br><span class="line">find()          查找一个元素，返回迭代器指向当前查找元素的位置否则返回map::end()位置</span><br><span class="line"></span><br><span class="line">count()         返回指定元素出现的次数</span><br><span class="line">		&#x2F;&#x2F; map和set两种容器的底层结构都是红黑树，所以容器中不会出现相同的元素，</span><br><span class="line">             &#x2F;&#x2F; 因此count()的结果只能为0和1，可以以此来判断键值元素是否存在</span><br><span class="line">             &#x2F;&#x2F;(当然也可以使用find()方法判断键值是否存在)。</span><br><span class="line"></span><br><span class="line">swap()           交换两个map</span><br><span class="line"></span><br><span class="line">lower_bound()   返回键值&gt;&#x3D;给定元素的第一个位置     </span><br><span class="line"></span><br><span class="line">upper_bound()    返回键值&gt;给定元素的第一个位置     </span><br><span class="line"></span><br><span class="line">equal_range()   返回特殊条目的迭代器对</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">int main() &#123;</span><br><span class="line">    map&lt;char, int&gt; mymap;</span><br><span class="line">    mymap[&#39;a&#39;] &#x3D; 3;</span><br><span class="line">    mymap[&#39;b&#39;] &#x3D; 4;</span><br><span class="line">    mymap[&#39;c&#39;] &#x3D; 5;</span><br><span class="line">    mymap[&#39;d&#39;] &#x3D; 6;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; mymap.lower_bound(&#39;c&#39;)-&gt;first &lt;&lt; endl;  &#x2F;&#x2F; 返回key &gt;&#x3D; &#39;c&#39;第一个元素的迭代器</span><br><span class="line">    cout &lt;&lt; mymap.upper_bound(&#39;c&#39;)-&gt;first &lt;&lt; endl;  &#x2F;&#x2F; 返回key &gt;  &#39;c&#39;第一个元素的迭代器</span><br><span class="line">    </span><br><span class="line">    pair&lt;map&lt;char, int&gt;::iterator, map&lt;char, int&gt;::iterator&gt; ret;</span><br><span class="line">    ret &#x3D; mymap.equal_range(&#39;c&#39;);</span><br><span class="line">    cout &lt;&lt; &quot;lower bound points to: &quot;;</span><br><span class="line">    cout &lt;&lt; ret.first-&gt;first &lt;&lt; &quot; &#x3D;&gt; &quot; &lt;&lt; ret.first-&gt;second &lt;&lt; &#39;\n&#39;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;upper bound points to: &quot;;</span><br><span class="line">    cout &lt;&lt; ret.second-&gt;first &lt;&lt; &quot; &#x3D;&gt; &quot; &lt;&lt; ret.second-&gt;second &lt;&lt; &#39;\n&#39;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">lower bound points to: c &#x3D;&gt; 5</span><br><span class="line">upper bound points to: d &#x3D;&gt; 6</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">get_allocator() 返回map的配置器</span><br><span class="line"></span><br><span class="line">key_comp()      返回比较元素key的函数</span><br><span class="line"></span><br><span class="line">value_comp()     返回比较元素value的函数</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>STL容器</category>
      </categories>
  </entry>
  <entry>
    <title>queue(队列与优先队列)</title>
    <url>/2020/08/15/queue/</url>
    <content><![CDATA[<h4 id="queue的常用成员函数"><a href="#queue的常用成员函数" class="headerlink" title="queue的常用成员函数"></a>queue的常用成员函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">front()：返回值为队列中的第一个元素，也就是最早、最先进入队列的元素。</span><br><span class="line">	&#x2F;&#x2F;注意这里只是返回最早进入的元素，并没有把它剔除出队列。</span><br><span class="line"></span><br><span class="line">back()：返回队列中最后一个元素，也就是最晚进去的元素。</span><br><span class="line">g</span><br><span class="line">push()：队列中由于是先进先出，push即在队尾插入一个元素。</span><br><span class="line">	&#x2F;&#x2F;这是通过调用底层容器的成员函数 push_back() 来完成的。</span><br><span class="line"></span><br><span class="line">pop()：将队列中最靠前位置的元素拿掉，是没有返回值的void函数。</span><br><span class="line"></span><br><span class="line">size()：返回队列中元素的个数，返回值类型为unsigned int。</span><br><span class="line"></span><br><span class="line">empty()：判断队列是否为空的，如果为空则返回true。</span><br><span class="line"></span><br><span class="line">emplace()：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。</span><br><span class="line"></span><br><span class="line">swap()：将当前 queue 中的元素和参数 queue 中的元素交换。</span><br><span class="line">	&#x2F;&#x2F;它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。</span><br><span class="line">    q1.swap(q2);</span><br><span class="line">    swap(q1,q2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="优先队列-priority-queue"><a href="#优先队列-priority-queue" class="headerlink" title="优先队列(priority_queue)"></a>优先队列(priority_queue)</h4><p>默认大顶堆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;升序队列，小顶堆</span><br><span class="line">priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;</span><br><span class="line">&#x2F;&#x2F;降序队列，大顶堆</span><br><span class="line">priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。</span><br><span class="line">&#x2F;&#x2F;其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span><br></pre></td></tr></table></figure>
<p><label style="color:red"> 用pair做优先队列元素的例子：</label></p>
<p>pair的比较，先比较第一个元素，第一个相等比较第二个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() </span><br><span class="line"> &#123;</span><br><span class="line">     priority_queue&lt;pair&lt;int, int&gt; &gt; a;</span><br><span class="line">     pair&lt;int, int&gt; b(1, 2);</span><br><span class="line">     pair&lt;int, int&gt; c(1, 3);</span><br><span class="line">     pair&lt;int, int&gt; d(2, 5);</span><br><span class="line">     a.push(d);</span><br><span class="line">     a.push(c);</span><br><span class="line">     a.push(b);</span><br><span class="line">     while (!a.empty()) </span><br><span class="line">     &#123;</span><br><span class="line">         cout &lt;&lt; a.top().first &lt;&lt; &#39; &#39; &lt;&lt; a.top().second &lt;&lt; &#39;\n&#39;;</span><br><span class="line">         a.pop();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">2 5</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<p><label style="color:red"> 用自定义类型做优先队列元素的例子</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法1</span><br><span class="line">struct tmp1 &#x2F;&#x2F;运算符重载&lt;</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    tmp1(int a) &#123;x &#x3D; a;&#125;</span><br><span class="line">    bool operator&lt;(const tmp1&amp; t) const</span><br><span class="line">    &#123;</span><br><span class="line">        return x &lt; t.x; &#x2F;&#x2F;大顶堆,,,&#x2F;&#x2F;return x &gt; t.x;小顶堆</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法2</span><br><span class="line">struct tmp2 &#x2F;&#x2F;重写仿函数</span><br><span class="line">&#123;</span><br><span class="line">    bool operator() (tmp1 a, tmp1 b)</span><br><span class="line">    &#123;</span><br><span class="line">        return a.x &lt; b.x; &#x2F;&#x2F;大顶堆,,,&#x2F;&#x2F;return a.x &gt; b.x;小顶堆</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    tmp1 a(1);</span><br><span class="line">    tmp1 b(2);</span><br><span class="line">    tmp1 c(3);</span><br><span class="line">    priority_queue&lt;tmp1&gt; d;</span><br><span class="line">    d.push(b);</span><br><span class="line">    d.push(c);</span><br><span class="line">    d.push(a);</span><br><span class="line">    while (!d.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; d.top().x &lt;&lt; &#39;\n&#39;;</span><br><span class="line">        d.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span><br><span class="line">    f.push(b);</span><br><span class="line">    f.push(c);</span><br><span class="line">    f.push(a);</span><br><span class="line">    while (!f.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; f.top().x &lt;&lt; &#39;\n&#39;;</span><br><span class="line">        f.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line"> </span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>STL容器</category>
      </categories>
  </entry>
  <entry>
    <title>set</title>
    <url>/2020/08/16/set/</url>
    <content><![CDATA[<p><label style="color:red"> </label></p>
<h4 id="set的常用函数"><a href="#set的常用函数" class="headerlink" title="set的常用函数"></a>set的常用函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin();            &#x2F;&#x2F; 返回指向第一个元素的迭代器，iterator</span><br><span class="line">end();              &#x2F;&#x2F; 返回指向最后一个元素的迭代器</span><br><span class="line">rbegin()		&#x2F;&#x2F;返回指向集合中最后一个元素的反向迭代器，reverse_iterator</span><br><span class="line">rend() 			&#x2F;&#x2F;返回指向集合中第一个元素的反向迭代器</span><br><span class="line">clear();            &#x2F;&#x2F; 清除所有元素</span><br><span class="line">count();            &#x2F;&#x2F; 返回某个值元素的个数,可以用来判断元素是否存在</span><br><span class="line">find()		    &#x2F;&#x2F;返回一个指向被查找到元素的迭代器</span><br><span class="line">erase()		   &#x2F;&#x2F;删除集合中的元素</span><br><span class="line">insert()		&#x2F;&#x2F;在集合中插入元素</span><br><span class="line">empty();            &#x2F;&#x2F; 如果集合为空，返回true</span><br><span class="line">size()			&#x2F;&#x2F;集合中元素的数目</span><br><span class="line">max_size()		&#x2F;&#x2F;返回集合能容纳的元素的最大限值 </span><br><span class="line">swap()			&#x2F;&#x2F;交换两个集合变量</span><br><span class="line"> </span><br><span class="line">lower_bound()	&#x2F;&#x2F;返回指向大于（或等于）某值的第一个元素的迭代器</span><br><span class="line">upper_bound()	&#x2F;&#x2F;返回大于某个值元素的迭代器</span><br><span class="line">equal_range();      &#x2F;&#x2F;返回集合中与给定值相等的上下限的两个迭代器，lower_bound()与upper_bound()的结合。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_allocator()	–返回集合的分配器</span><br><span class="line">key_comp()	–返回一个用于元素间值比较的函数</span><br><span class="line">value_comp()	–返回一个用于比较元素间的值的函数</span><br></pre></td></tr></table></figure>
<h4 id="c-stl集合set插入-遍历用法举例"><a href="#c-stl集合set插入-遍历用法举例" class="headerlink" title="c++ stl集合set插入,遍历用法举例"></a>c++ stl集合set插入,遍历用法举例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt; </span><br><span class="line">#include&lt;set&gt; </span><br><span class="line">using namespace std; </span><br><span class="line">&#x2F;&#x2F;set插入元素操作  </span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    &#x2F;&#x2F;定义一个int型集合对象s,当前没有任何元素.由www.169it.com搜集整理</span><br><span class="line">    set&lt;int&gt; s; </span><br><span class="line">    s.insert(8);  &#x2F;&#x2F;第一次插入8，可以插入  </span><br><span class="line">    s.insert(1); </span><br><span class="line">    s.insert(12); </span><br><span class="line">    s.insert(6); </span><br><span class="line">    s.insert(8);   &#x2F;&#x2F;第二次插入8，重复元素，不会插入  </span><br><span class="line">    set&lt;int&gt;::iterator it; &#x2F;&#x2F;定义前向迭代器 </span><br><span class="line">    &#x2F;&#x2F;中序遍历集合中的所有元素  </span><br><span class="line">    for(it&#x3D;s.begin();it!&#x3D;s.end();it++) </span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;endl;    </span><br><span class="line">    system(&quot;pause&quot;); </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>STL容器</category>
      </categories>
  </entry>
  <entry>
    <title>socket传输</title>
    <url>/2020/07/23/socket%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<h3 id="服务器-Linux"><a href="#服务器-Linux" class="headerlink" title="服务器(Linux)"></a>服务器(Linux)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//头文件</span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fstream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;opencv2/opencv.hpp&gt;</span></span><br><span class="line"><span class="comment">#include &lt;pthread.h&gt;</span></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const char* IP = <span class="string">&quot;192.168.2.10&quot;</span>;//IP地址</span><br><span class="line"><span class="comment">#define port 8000 //端口号</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Server begin!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    int socketServer = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">    //设置服务器套接字ip和端口</span><br><span class="line">    struct sockaddr_in serverSockaddr;</span><br><span class="line">    serverSockaddr.sin_family = AF_INET;</span><br><span class="line">    serverSockaddr.sin_port = htons(8000);</span><br><span class="line">    serverSockaddr.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">	//绑定操作</span><br><span class="line">    <span class="built_in">bind</span>(socketServer,(struct sockaddr*)&amp;serverSockaddr,sizeof(serverSockaddr))</span><br><span class="line">   //监听操作</span><br><span class="line">    listen(socketServer,5)</span><br><span class="line">   //接受客户端请求</span><br><span class="line">    struct sockaddr_in clientSockaddr;//客户端套接字</span><br><span class="line">    socklen_t nAddrlen = sizeof(clientSockaddr);</span><br><span class="line">int socketClient = accept(socketServer,(struct sockaddr*)&amp;clientSockaddr,&amp;nAddrlen);</span><br><span class="line">     </span><br><span class="line">  //开始数据传输</span><br><span class="line">  //==============================================</span><br><span class="line">    Mat input_image=imread(<span class="string">&quot;11.bmp&quot;</span>,0);</span><br><span class="line">    unsigned char *brga=input_image.data;</span><br><span class="line">    unsigned long imgsize=1000;//brga的数据大小</span><br><span class="line">    </span><br><span class="line">    char revData[2048];</span><br><span class="line">    char tt[16]=&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">    int ai=100;</span><br><span class="line">    <span class="keyword">while</span>(ai&gt;0)&#123;</span><br><span class="line">     	sprintf(tt,<span class="string">&quot;%lu&quot;</span>,imgsize);//数字转字符，然后进行传输</span><br><span class="line">         send(socketClient,tt,sizeof(tt),0);</span><br><span class="line">         recv(socketClient,revData,2048,0);//服务器接受后发一个消息表示收到</span><br><span class="line">         send(socketClient,brga,imgsize,0);//发送数据</span><br><span class="line">         ai--;</span><br><span class="line">       &#125;</span><br><span class="line">   //=======================数据发送完毕</span><br><span class="line">    </span><br><span class="line">    shutdown(socketClient,SHUT_WR);//文件读取完毕，断开输出流，向客户端发送FIN包  </span><br><span class="line">    recv(socketClient,revData,2048,0);//阻塞，等待客户端接收完毕</span><br><span class="line">    close(socketClient);</span><br><span class="line">    close(socketServer);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The app exit！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端-Windows"><a href="#客户端-Windows" class="headerlink" title="客户端(Windows)"></a>客户端(Windows)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;winsock2.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;Windows.h&gt;  </span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;time.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="line"><span class="comment">#pragma comment(lib, &quot;ws2_32.lib&quot;)  </span></span><br><span class="line"></span><br><span class="line">const char* IP = <span class="string">&quot;192.168.2.10&quot;</span>;</span><br><span class="line"><span class="comment">#define BUF_SIZE  2048</span></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	WSAStartup(MAKEWORD(2, 2), &amp;wsaData);</span><br><span class="line">	SOCKET sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); //IPPROTO_TCP</span><br><span class="line">	//定义套接字绑定ip和端口</span><br><span class="line">	sockaddr_in sockAddr;</span><br><span class="line">	memset(&amp;sockAddr, 0, sizeof(sockAddr));</span><br><span class="line">	sockAddr.sin_family = AF_INET;</span><br><span class="line">	sockAddr.sin_port = htons(8000);</span><br><span class="line">	sockAddr.sin_addr.s_addr = inet_addr(IP);</span><br><span class="line">	//进行连接</span><br><span class="line">	int ret=connect(sock, (SOCKADDR*)&amp;sockAddr, sizeof(sockAddr));</span><br><span class="line">    //===========================开始传输 =================</span><br><span class="line">    char tt[16];</span><br><span class="line">    char* s = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    int needrecv;</span><br><span class="line">    int cc = 0;</span><br><span class="line">    int nCount;</span><br><span class="line">    char* kk = new  char[4024 * 3036 ];</span><br><span class="line">    </span><br><span class="line">    int ai = 20;</span><br><span class="line">	 <span class="keyword">while</span> (ai&gt;0)&#123;</span><br><span class="line">		 cc = 0;</span><br><span class="line">		 recv(sock, tt, sizeof(tt), 0);</span><br><span class="line">		 needrecv = strtoul(tt, 0, 10);//接受传过来的数据大小</span><br><span class="line">		 send(sock, s, 100, 0);//发消息告诉服务器，收到数据了</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">while</span> (cc&lt;needrecv)&#123;	</span><br><span class="line">           //接受数据存放在kk里面</span><br><span class="line">			 nCount = recv(sock, kk + cc, needrecv-cc, 0);</span><br><span class="line">			 cc += nCount;</span><br><span class="line">			 <span class="keyword">if</span> (nCount &lt; 0)</span><br><span class="line">			 <span class="built_in">break</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 ai--;</span><br><span class="line">	 &#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;File transfer success!&quot;</span>&lt;&lt;endl;</span><br><span class="line">	//文件接收完毕后直接关闭套接字，无需调用shutdown()  </span><br><span class="line">	closesocket(sock);</span><br><span class="line">	WSACleanup();</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>socket通信</category>
      </categories>
  </entry>
  <entry>
    <title>stack(栈)</title>
    <url>/2020/08/16/stack/</url>
    <content><![CDATA[<h4 id="stack的常用成员函数"><a href="#stack的常用成员函数" class="headerlink" title="stack的常用成员函数"></a>stack的常用成员函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">empty() 堆栈为空则返回真</span><br><span class="line">pop() 移除栈顶元素</span><br><span class="line">push() 在栈顶增加元素</span><br><span class="line">size() 返回栈中元素数目</span><br><span class="line">top() 返回栈顶元素</span><br></pre></td></tr></table></figure>
<h4 id="应用例子"><a href="#应用例子" class="headerlink" title="应用例子"></a>应用例子</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<p><strong>分析</strong></p>
<p>应用一个辅助栈，主栈A用来保存实际数据，辅栈B用来保存最小元素。压栈的时候，如果元素比B的栈顶小，则将该元素同时压入A栈和B栈，否则只压A栈；出栈的时候，若A栈顶元素等于B栈顶元素，则同时出栈，否则A出栈B不出栈。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    stack&lt;int&gt; stack1,stack2;</span><br><span class="line">    void push(int value) &#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">        if(stack2.empty())</span><br><span class="line">            stack2.push(value);</span><br><span class="line">        else&#123;</span><br><span class="line">            if(value &lt; stack2.top())</span><br><span class="line">                stack2.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void pop() &#123;</span><br><span class="line">        if(stack1.top() &#x3D;&#x3D; stack2.top())&#123;</span><br><span class="line">            stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;</span><br><span class="line">        return stack1.top();</span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;</span><br><span class="line">        return stack2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>STL容器</category>
      </categories>
  </entry>
  <entry>
    <title>string(字符串)</title>
    <url>/2020/08/17/string/</url>
    <content><![CDATA[<h4 id="string对象的定义和初始化"><a href="#string对象的定义和初始化" class="headerlink" title="string对象的定义和初始化"></a>string对象的定义和初始化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s1;		默认构造函数，s1位空串</span><br><span class="line">string s2(s1);		将s2初始化为s1的一个副本</span><br><span class="line">string s3(&quot;value&quot;);	将s3初始化为一个字符串字面值副本</span><br><span class="line">string s4(n,&#39;c&#39;)	将s4初始化为字符&#39;c&#39;的n个副本</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s1;</span><br><span class="line">    s1&#x3D;&quot;chenchen&quot;;</span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    string s2(s1);</span><br><span class="line">    cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    string s3(&quot;value&quot;);</span><br><span class="line">    cout&lt;&lt;s3&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    string s4(10,&#39;c&#39;);</span><br><span class="line">    cout&lt;&lt;s4&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/21.png"></p>
<p>构造string对象的其他方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s(cp,n)		创建一个string对象，它被初始化为cp所指向数组的前n个元素副本</span><br><span class="line">string s(s2,pos2)	创建一个string对象，它被初始化为一个已存在的string对象s2中从下标pos2开始的字符的副本</span><br><span class="line">				如果pos2&gt;s.size(),则该操作未定义</span><br><span class="line"></span><br><span class="line">string s(s2,pos2,len2)	创建一个string对象，它被初始化为s2中从下标pos2开始的len2个字符的副本</span><br><span class="line">				如果pos2&gt;s2.size(),则该操作未定义</span><br><span class="line">				无论len2的值是多少，最多只能复制s2.size()-pos2个字符</span><br></pre></td></tr></table></figure>


<h4 id="string对象的操作"><a href="#string对象的操作" class="headerlink" title="string对象的操作"></a>string对象的操作</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.empty()		如果s为空串，则返回true，否则返回false</span><br><span class="line">s.size()		返回s 中字符的字符个数</span><br><span class="line">s[n]			返回s中位置为n的字符，位置从0开始计数</span><br><span class="line">s1+s2			把s1和s2链接成一个新的字符串，返回新生成的字符串</span><br><span class="line">s1&#x3D;s2			把s1内容替换为s2的副本</span><br><span class="line">v1&#x3D;&#x3D;v2			判断v1与v2的内容，相等则返回true，否则返回false</span><br><span class="line">!&#x3D;, &lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;	保持这些操作的惯有含义</span><br></pre></td></tr></table></figure>
<p><label style="color:red"> 因为string 的字符会很长，所以有了string::size_type 类型</label><br>注意s.size()返回的类型是string::size_type()类型，而不是int形，string::size_type 的类型长度是int的俩倍所以尽量让s.size()的返 回值给string::size_type 类型</p>
<p><label style="color:red"> 和字符串字面值的连接问题</label>字符串字面值是一串常量字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s1&#x3D;&quot;hello&quot;;</span><br><span class="line">    string s2&#x3D;(&quot;world&quot;);</span><br><span class="line">    string s3&#x3D;s1+&quot;, &quot;;&#x2F;&#x2F;正确的</span><br><span class="line">    cout&lt;&lt;s3&lt;&lt;endl;</span><br><span class="line">&#x2F;&#x2F;    string s4&#x3D;&quot;hello&quot;+&quot;, &quot;;&#x2F;&#x2F;错误的</span><br><span class="line">    string s5&#x3D;s1+&quot;, &quot;+&quot;, &quot;+&quot;world&quot;;&#x2F;&#x2F;错误的</span><br><span class="line">&#x2F;&#x2F;    string s6&#x3D;&quot;hello&quot;+&quot;, &quot;+s2;&#x2F;&#x2F;错误的</span><br><span class="line">    cout&lt;&lt;s5&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><label style="color:red"> 注意俩个字符串字面值相加，是非法的</label></p>
<h4 id="string-的遍历"><a href="#string-的遍历" class="headerlink" title="string 的遍历"></a>string 的遍历</h4><p><label style="color:red">注意：</label>除了一些特殊操作，string类型提供与vector容器相同的操作。string类型和vector容器不同的是，它不支持以栈方式操纵容器：在string类型中不能使用front,back,pop_back操作</p>
<p>string 是支持push_back()的，因为string也是顺序容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s(&quot;Hiya&quot;);</span><br><span class="line">    string::iterator it;</span><br><span class="line">    for(it&#x3D;s.begin();it!&#x3D;s.end();++it)</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;endl;</span><br><span class="line">    for(int i&#x3D;0;s[i];i++)</span><br><span class="line">        cout&lt;&lt;s[i]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改string对象的其他方法"><a href="#修改string对象的其他方法" class="headerlink" title="修改string对象的其他方法"></a>修改string对象的其他方法</h4><p>与容器共有的string操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.insert(p,t)	在迭代器p指向的元素之前插入一个值为t的新元素。返回指向新插入元素的迭代器</span><br><span class="line">s.insert(p,n,t)	在迭代器p指向的元素之前插入n个值为t的新元素。返回void</span><br><span class="line">s.insert(p,b,e)	在迭代器p指向的元素之前插入b和e标记范围内所有的元素，返回void</span><br><span class="line">s.assign(b,e)	用迭代器b和e标记范围内的元素替换s。对于string类型，该操作返回s，对于容器类型，则返回void</span><br><span class="line">s.assign(n,t)	用值为t的n个副本替换s。对于string类型，该操作返回s，对于容器类型，返回void</span><br><span class="line">s.erase(p)	删除迭代器p指向的元素，返回一个迭代器，指向被删除元素后面的元素</span><br><span class="line">s.erase(b,e)	删除迭代器b和e标记范围内所有的元素，返回一个迭代器，指向被删除元素段后面的第一个元素</span><br><span class="line">reverse(b,e)	把迭代器b和e标记范围内的所有元素反转</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s&#x3D;&quot;12345abcde&quot;;</span><br><span class="line">    string::iterator it;</span><br><span class="line">    it&#x3D;s.begin();</span><br><span class="line">    s.insert(it+2,&#39;s&#39;);</span><br><span class="line">    cout&lt;&lt;&quot;s&#x3D;&quot;&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    it&#x3D;s.begin();</span><br><span class="line">    s.insert(it+2,2,&#39;t&#39;);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    it&#x3D; s.begin();</span><br><span class="line">    s.assign(it,it+3);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    s.assign(10,&#39;c&#39;);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    string s1&#x3D;&quot;sfdfsaf&quot;;</span><br><span class="line">    s1.erase(s1.begin());</span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    s1.erase(s1.begin(),s1.begin()+3);</span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    reverse(s1.begin(),s1.end());</span><br><span class="line">    cout&lt;&lt;s1&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/22.png"></p>
<p>string 类型特有的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.insert(pos,n,c)			在下表pos的元素之前插入n个字符c</span><br><span class="line">s.insert(pos,s2)			在下标为pos的元素之前插入string对象s2的副本</span><br><span class="line">s.insert(pos,s2,pos2,len)		在下标为pos的元素之前插入s2中从下标pos2开始len个字符</span><br><span class="line">s.insert(pos,cp,len)			在下标为pos的元素之前插入s2中从下标pos2开始的len个字符</span><br><span class="line">s.insert(pos,cp)			在下标为pos的元素之前插入cp所指向的以空字符结束的字符串副本</span><br><span class="line">s.assign(s2)				用s2的副本替换s</span><br><span class="line">s.assign(s2,pos2,len)			用s2中从下标pos2开始的len个字符副本替换s</span><br><span class="line">s.assign(cp,len)			用cp所指向数组的前len个字符副本替换s</span><br><span class="line">s.assign(cp)				用cp所指向的以空字符结束的字符串副本替换s</span><br><span class="line">s.erase(pos,len)			删除从下标pos开始的len个字符</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s&#x3D;&quot;12345abcde&quot;;</span><br><span class="line">    s.insert(2,2,&#39;s&#39;);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    string s2&#x3D;&quot;zyz&quot;;</span><br><span class="line">    s.insert(1,s2);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    s.insert(0,s2,0,2);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    char *cp&#x3D;&quot;Statelu pou&quot;;</span><br><span class="line">    s.insert(0,cp);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    s.insert(0,cp,2);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    string s3&#x3D;&quot;123456abc&quot;;</span><br><span class="line">    s.assign(s3);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    string s4&#x3D;&quot;987&quot;;</span><br><span class="line">    s.assign(s4,0,3);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    s.erase(1,6);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/23.png"></p>
<h4 id="string子串的操作"><a href="#string子串的操作" class="headerlink" title="string子串的操作"></a>string子串的操作</h4><p>substr函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.substr(pos,n)	返回一个string类型的字符串，它包含s中从下标pos开始的n个字符</span><br><span class="line">s.substr(pos)	返回一个string类型的字符串，它包含从下标pos开始到s末为的所有字符</span><br><span class="line">s.substr()	返回s的副本</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s(&quot;hello world&quot;);</span><br><span class="line">    string s2&#x3D;s.substr(6,5);</span><br><span class="line">    cout&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line">    string s3&#x3D;s.substr(6);</span><br><span class="line">    cout&lt;&lt;s3&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>append和replace函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.append(args)		将args串接在s后面。返回s的引用</span><br><span class="line">s.replace(pos,len,args)	删除s中从下标pos开始的len个字符，用args指定的字符替换之，返回s的引用</span><br><span class="line">			这个版本中，args不能为b2，e2</span><br><span class="line"></span><br><span class="line">s.replace(b,e,args)	删除迭代器b和e标记的范围内所有的字符，用args代替之。返回s的引用</span><br><span class="line">			这个版本中，args不能为 s1,pos2,len2</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">s2			string类型的字符串s2</span><br><span class="line">s2,pos1,pos2		字符串s2中从下标pos2开始的len2个字符</span><br><span class="line">cp			指针cp指向的以空字符结束的数组</span><br><span class="line">cp,len2			cp指向的以空字符结束的数组中前len2个字符</span><br><span class="line">n,c			字符c的n个副本</span><br><span class="line">b2,e2			迭代器b2和e2标记的范围内所有字符</span><br><span class="line">                                      </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s(&quot;C++ Prime&quot;);</span><br><span class="line">    s.append(&quot; 3rd Ed&quot;);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    s.insert(s.size(),&quot;w&quot;);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    s.replace(10,3,&quot;4th&quot;);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    s.erase(10,3);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    s.insert(10,&quot;4th&quot;);</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/24.png"></p>
<p>一系列find函数，用于查找string对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.find(args)			在s中查找args的第一次出现</span><br><span class="line">s.rfind(args)			在s中查找args的最后一次出现</span><br><span class="line">s.find_first_of(args)		在s中查args的任意字符的第一次出现</span><br><span class="line">s.find_last_of(args)		在s中查找args的任意字符的最后一次出现</span><br><span class="line">s.find_first_not_of(args)	在s中查找第一个不属于args的字符</span><br><span class="line">s.find_last_not_of(args)	在s中查找最后一个不属于args的字符</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">c,pos		在s中，从下标pos标记的位置开始，查找字符c、pos的默认值是0</span><br><span class="line">s2,pos		在s中，从下标pos标记的位置开始，查找string对象s2，pos的默认值为0</span><br><span class="line">cp,pos		在s中从下标pos标记的位置开始，查找cp所指向的c风格的以空格结束的字符串。pos默认值为0</span><br><span class="line">cp,pos,n	在s中，从下标pos标记的位置开始，查找指针cp所指向数组的前n个字符，pos和n都没有默认值</span><br></pre></td></tr></table></figure>
<h4 id="string对象的比较"><a href="#string对象的比较" class="headerlink" title="string对象的比较"></a>string对象的比较</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.compare(s2)			比较s和s2</span><br><span class="line">s.compare(pos1,n1,s2)		让s中从pos下标位置开始的n1个字符与s2做比较</span><br><span class="line">s.compare(pos1,n1,s2,pos2,n2)	让s中从pos1下标位置开始的n1个字符与s2中从pos2下标位置开始的n2个字符做比较</span><br><span class="line">s.compare(cp)		比较s和cp所指向的以空字符结束的字符串</span><br><span class="line">s.compare(pos1,n1,cp)		让s从pos1下标位置开始的n1个字符与cp所指向的字符串做比较</span><br><span class="line">s.compare(pos1,n1,cp,n2)	让s中从pos1下标位置开始的n1个字符与cp所指向字符串的前n2个字符做比较</span><br></pre></td></tr></table></figure>
<p>比如：s1.compare(args);<br>正数，此时s1大于args所代表的string对象<br>负数，此时s1小于args所代表的string对象<br>0,此时s1恰好等于args所代表的string对象</p>
<h4 id="字符串和整数之间的互相转换"><a href="#字符串和整数之间的互相转换" class="headerlink" title="字符串和整数之间的互相转换"></a>字符串和整数之间的互相转换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">to_string (int val);&#x2F;&#x2F;将数值转化为字符串。返回对应的字符串。</span><br><span class="line"></span><br><span class="line">string perfect &#x3D; to_string(9) + &quot; is a perfect number&quot;;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">stoi（字符串，起始位置，n进制） &#x2F;&#x2F;将 n 进制的字符串转化为十进制</span><br><span class="line"></span><br><span class="line">int a &#x3D; 4;</span><br><span class="line">double b &#x3D; 3.14;</span><br><span class="line">string str1, str2;</span><br><span class="line">str1 &#x3D; to_string(a);</span><br><span class="line">str2 &#x3D; to_string(b);</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">int atoi(const char *str );&#x2F;&#x2F;把字符串转换成整型数。</span><br><span class="line"></span><br><span class="line">int a;</span><br><span class="line">char *ptr1 &#x3D; &quot;-12345&quot;;</span><br><span class="line">a &#x3D; atoi(ptr1);</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">char *itoa( int value, char *string,int radix);</span><br><span class="line">&#x2F;&#x2F;将整数value 转换成字符串存入string 指向的内存空间 ,radix 为转换时所用基数(保存到字符串中的数据的进制基数)。</span><br><span class="line"></span><br><span class="line">int num &#x3D; 10;</span><br><span class="line">char str[100];</span><br><span class="line">itoa(num, str, 2);</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">c_str()的作用是将const string*转化为const char*</span><br><span class="line"></span><br><span class="line">string s1(&quot;1234567&quot;);</span><br><span class="line">int c &#x3D; atoi(s1.c_str());</span><br></pre></td></tr></table></figure>
































]]></content>
      <categories>
        <category>STL容器</category>
      </categories>
  </entry>
  <entry>
    <title>编译jpeglib库</title>
    <url>/2020/07/23/vs2013%E7%BC%96%E8%AF%91jpeglib%E5%BA%93/</url>
    <content><![CDATA[<h4 id="vs2013编译jpeglib"><a href="#vs2013编译jpeglib" class="headerlink" title="vs2013编译jpeglib"></a>vs2013编译jpeglib</h4><p>下载源代码下载地址：<a href="http://www.ijg.org/files/">http://www.ijg.org/files/</a></p>
<p>第一步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打开“jpeg-9a”文件夹下面的“makefile.vc”文件找到里面的“!include &lt;win32.mak&gt;”,将“win32.mak”改为绝对路径。</span><br><span class="line">“!include &lt;C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\Include\win32.mak&gt;”</span><br><span class="line"></span><br><span class="line">win32.mak是VS下的一个文件，VS2013版本默认在“C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\Include”。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打开VS2013的命令行:“VS2013 x86 本机工具命令提示”</span><br><span class="line"></span><br><span class="line">开始菜单，找到“Visual Studio 2013”，打开“Visual Studio Tools”文件夹。</span><br><span class="line"></span><br><span class="line">打开命令行之后cd到解压出来的“jpeg-9a”目录下，输入“nmake &#x2F;f makefile.vc setup-v10”，回车。</span><br><span class="line"></span><br><span class="line">待命令行执行完命令后，准备工作就大功告成啦。关于命令行的操作，具体如下图：</span><br></pre></td></tr></table></figure>
<p><img src="/img/3.png"></p>
<p>第三步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">直接运行“jpeg-9a”文件夹下生成的“jpeg.sln”，VS提示要升级编译器点是，进入编程界面后右击项目生成或者重新生成。</span><br><span class="line"></span><br><span class="line">编译完成后在“jpeg-9a”文件夹下的“Release”文件夹中可以看到一个“jpeg.lib”文件，这个就是我们刚刚编译出来的静态链接库。</span><br><span class="line"></span><br><span class="line">要使用这个静态链接库，只要先包含进jconfig.h，jmorecfg.h，jpeglib.h这三个头文件，然后把刚刚编译出来的jpeg.lib加进工程中就可以了。</span><br></pre></td></tr></table></figure>
<h4 id="ubuntu编译jpeglib"><a href="#ubuntu编译jpeglib" class="headerlink" title="ubuntu编译jpeglib"></a>ubuntu编译jpeglib</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf  jpegsrc.v8b.tar.gz</span><br><span class="line">cd jpeg-8b</span><br><span class="line">.&#x2F;configure  --enable-shared </span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>jpeglib压缩</category>
      </categories>
  </entry>
  <entry>
    <title>冒泡排序,选择排序</title>
    <url>/2020/08/17/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>算法步骤</strong></p>
<p>1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
<p>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
<p>3.针对所有的元素重复以上的步骤，除了最后一个。</p>
<p>4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p><strong>算法步骤</strong></p>
<p>1.首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p>
<p>2.再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</p>
<p>3.重复第二步，直到所有元素均排序完毕</p>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
  </entry>
  <entry>
    <title>位操作题目_华为笔试</title>
    <url>/2020/08/29/%E4%BD%8D%E6%93%8D%E4%BD%9C%E9%A2%98%E7%9B%AE-%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<p><strong>题目描述</strong><br>对输入n个无符号整数，进行二进制的移位和调换进行加扰，加扰后仍然保持n个整数。输出加扰后的n个整数，俩个整数之间空格分开。</p>
<p>加扰步骤：<br>1，先把每个整数每俩个bit交换位置，如bit0和bit1交换，bit2和bit3交换，依此类推。<br>2，再把每个整数向右移2位，溢出的部分，第一个整数的最低2bit移到第二个整数的最高俩bit上，第二个帧数的最低2bit移到第三个整数的最高俩bit上，依此类推，最后一个整数的最低2bit移到第一个整数的最高2bit上。如果输入只有一个整数，溢出的2bit移到自己的最高2bit上。</p>
<p>说明，无符号整数的范围不超过32bit整数大小。<br><strong>输入描述</strong><br>输入n个无符号整数，俩个整数直接用空格分开。n不超过1000。<br><strong>输出描述</strong><br>输出加扰后的无符号整数，俩个整数直接用空格分开</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2  &#x2F;&#x2F;输入</span><br><span class="line"></span><br><span class="line">1073741824 2147483648  &#x2F;&#x2F;输出</span><br></pre></td></tr></table></figure>

<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	string s1;</span><br><span class="line">	getline(cin, s1);</span><br><span class="line">	istringstream is(s1);</span><br><span class="line">	vector&lt;unsigned int&gt; num;</span><br><span class="line">	while (is &gt;&gt; s1)&#123;</span><br><span class="line">		num.emplace_back(stoi(s1));</span><br><span class="line">		&#x2F;&#x2F;num.emplace_back(atoi(s1.c_str()));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;交换</span><br><span class="line">	for (int i &#x3D; 0; i &lt; num.size(); i++)&#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; 32; j +&#x3D; 2)&#123;</span><br><span class="line">			unsigned int di &#x3D; num[i] &amp; (1 &lt;&lt; j);</span><br><span class="line">			unsigned int gao &#x3D; num[i] &amp; (1 &lt;&lt; (j + 1));</span><br><span class="line"></span><br><span class="line">			num[i] &#x3D; num[i] &amp; (~(1 &lt;&lt; j));</span><br><span class="line">			num[i] &#x3D; num[i] &amp; (~(1 &lt;&lt; (j + 1)));</span><br><span class="line"></span><br><span class="line">			&#x2F;*auto o1 &#x3D; di*(1 &lt;&lt; (j + 1));</span><br><span class="line">			auto o2 &#x3D; gao*(1 &lt;&lt; j);*&#x2F;</span><br><span class="line">			num[i] &#x3D; num[i] | (gao &gt;&gt; 1) | (di&lt;&lt;1 );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;右移</span><br><span class="line">	unsigned int bit;</span><br><span class="line">	unsigned int bit_end &#x3D; num[num.size() - 1] &amp; 3;&#x2F;&#x2F;存最低俩位</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; num.size() - 1; i &gt; 0; i--)&#123;</span><br><span class="line">		bit &#x3D; num[i - 1] &amp; 3;&#x2F;&#x2F;存最低俩位</span><br><span class="line"></span><br><span class="line">		num[i] &#x3D; num[i] &gt;&gt; 2;</span><br><span class="line">		unsigned int jinwei &#x3D; bit&lt;&lt;30;&#x2F;&#x2F;移到最高俩位</span><br><span class="line">		num[i] |&#x3D; jinwei;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	num[0] &#x3D; num[0] &gt;&gt; 2;</span><br><span class="line">	unsigned int jinwei &#x3D; bit_end &lt;&lt; 30;;</span><br><span class="line">	num[0] |&#x3D; jinwei;</span><br><span class="line"></span><br><span class="line">	for (auto i : num)</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>刷题</category>
        <category>收藏题</category>
      </categories>
  </entry>
  <entry>
    <title>剑-03 数组中重复的数字(哈希表思想)</title>
    <url>/2020/07/22/%E5%89%91-03/</url>
    <content><![CDATA[<h3 id="找出数组中重复的数字。"><a href="#找出数组中重复的数字。" class="headerlink" title="找出数组中重复的数字。"></a>找出数组中重复的数字。</h3><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>
<p>限制：<br>2 &lt;= n &lt;= 100000</p>
<h3 id="解答：哈希表思想。"><a href="#解答：哈希表思想。" class="headerlink" title="解答：哈希表思想。"></a>解答：哈希表思想。</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line"></span><br><span class="line">        int* a=new int[nums.size()];</span><br><span class="line">        memset(a,0,nums.size());//给数组初始话赋值</span><br><span class="line">        </span><br><span class="line">        //哈希表思想</span><br><span class="line">        <span class="keyword">for</span> (int i=0;i&lt;nums.size();i++) &#123;    </span><br><span class="line">           <span class="keyword">if</span>(a[nums[i]]==1)&#123;</span><br><span class="line">               <span class="built_in">return</span> nums[i];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               a[nums[i]]=1;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-04 二维数组中的查找</title>
    <url>/2020/07/22/%E5%89%91-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<p>限制：<br>0 &lt;= n &lt;= 1000;<br>0 &lt;= m &lt;= 1000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size()==0)&#123; //考虑边界</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        int n=matrix.size();</span><br><span class="line">        int m=matrix[0].size();</span><br><span class="line">        int i=n-1;</span><br><span class="line">        int j=0;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=0&amp;&amp;j&lt;m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==target)&#123;</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j]&gt;target)&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-06 从尾到头打印链表(改变链表结构)</title>
    <url>/2020/07/22/%E5%89%91-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>示例 1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<p>限制：0 &lt;= 链表长度 &lt;= 10000</p>
<h3 id="解答：改变链表结构"><a href="#解答：改变链表结构" class="headerlink" title="解答：改变链表结构"></a>解答：改变链表结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; a;</span><br><span class="line">        <span class="keyword">if</span>(head==NULL )&#123;</span><br><span class="line">            <span class="built_in">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span>( head-&gt;next==NULL )&#123;</span><br><span class="line">            a.push_back(head-&gt;val);</span><br><span class="line">            <span class="built_in">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p=head;//不动</span><br><span class="line">        //俩个不断变换，实现链表反转。</span><br><span class="line">        ListNode *list=head;//前一个</span><br><span class="line">        ListNode *pN=head-&gt;next;//当前</span><br><span class="line">        <span class="keyword">while</span>(pN!=NULL)&#123;</span><br><span class="line">            p-&gt;next=pN-&gt;next;/保存当前结点的下一个节点</span><br><span class="line">            pN-&gt;next=list;//当前结点指向前一个节点，反向改变指针</span><br><span class="line">            list=pN;//更新前一个节点</span><br><span class="line">            pN=p-&gt;next;//更新当前结点</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(list!=NULL)&#123;</span><br><span class="line">            a.push_back(list-&gt;val);</span><br><span class="line">            list=list-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 解答：还可以采用递归，入栈法。</p>
]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-07 重建二叉树(根据前序中序)</title>
    <url>/2020/07/23/%E5%89%91-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p>例如，给出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>限制：0 &lt;= 节点个数 &lt;= 5000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        //递归分治</span><br><span class="line">        int pb=0;</span><br><span class="line">        int ib=0;</span><br><span class="line">        int pe=preorder.size();</span><br><span class="line">        int ie=inorder.size();</span><br><span class="line">        <span class="built_in">return</span> recursionBuild( preorder, pb, pe, inorder, ib, ie);</span><br><span class="line">    &#125;</span><br><span class="line">    //递归分治</span><br><span class="line">    TreeNode* recursionBuild(vector&lt;int&gt;&amp; preorder,int pb,int pe, vector&lt;int&gt;&amp; inorder,int ib,int ie ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ib==ie) <span class="built_in">return</span> NULL;//递归终止条件，叶节点是ib=ie</span><br><span class="line">        TreeNode* cur = new TreeNode(preorder[pb]);//根节点</span><br><span class="line">        int index=-1;</span><br><span class="line">        <span class="keyword">for</span>(int i=ib;i&lt;ie;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==preorder[pb])&#123;</span><br><span class="line">                index=i;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = recursionBuild(preorder,pb+1,pb+1+(index-ib),inorder,ib,index);</span><br><span class="line">        //重建左子树，将左子树的前序和中序传入</span><br><span class="line">        cur-&gt;right = recursionBuild(preorder,pb+1+(index-ib),pe,inorder,index+1,ie);</span><br><span class="line">        //重建右子树，将右子树的前序和中序传入</span><br><span class="line">        <span class="built_in">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-05 替换空格</title>
    <url>/2020/07/22/%E5%89%91-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 </p>
<p>示例 1：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;We are happy.&quot;</span></span><br><span class="line">输出：<span class="string">&quot;We%20are%20happy.&quot;</span></span><br></pre></td></tr></table></figure>
<p>限制：<br>0 &lt;= s 的长度 &lt;= 10000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>方法一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string replaceSpace(string s) &#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(auto c : s)&#123; //auto即char</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                res += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	 //和方法一差不多区别在于string的操作方式</span><br><span class="line">    string replaceSpace(string s) &#123;</span><br><span class="line">        string ss;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                ss.push_back(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">                ss.push_back(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">                ss.push_back(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ss.push_back(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> ss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-09 用两个栈实现队列</title>
    <url>/2020/07/23/%E5%89%91-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>
<p>提示：<br>1 &lt;= values &lt;= 10000</p>
<p>最多会对 appendTail、deleteHead 进行 10000 次调用</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class CQueue &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="function"><span class="title">CQueue</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void appendTail(int value) &#123;</span><br><span class="line">        s1.push(value);//放进第一个栈</span><br><span class="line">    &#125;</span><br><span class="line">    int <span class="function"><span class="title">deleteHead</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.empty())&#123;//为空则将第一个栈全部放进第二个栈，再取出</span><br><span class="line">            <span class="keyword">if</span>(s1.empty())&#123;</span><br><span class="line">                <span class="built_in">return</span> -1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">                int a=s1.top();</span><br><span class="line">                s2.push(a);</span><br><span class="line">                s1.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        //第二个栈不为空直接取出</span><br><span class="line">        int k=s2.top();</span><br><span class="line">        s2.pop();</span><br><span class="line">        <span class="built_in">return</span> k ;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; s1;</span><br><span class="line">    stack&lt;int&gt; s2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your CQueue object will be instantiated and called as such:</span><br><span class="line"> * CQueue* obj = new CQueue();</span><br><span class="line"> * obj-&gt;appendTail(value);</span><br><span class="line"> * int param_2 = obj-&gt;deleteHead();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>






























]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-10-I 斐波那契数列</title>
    <url>/2020/07/23/%E5%89%91-10-I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>写一个函数，输入n，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p>提示：<br>0 &lt;= n &lt;= 100</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int fib(int n) &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">         int a&#x3D;0;</span><br><span class="line">         int b&#x3D;1;</span><br><span class="line">         int c&#x3D;0;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            c&#x3D;a+b;</span><br><span class="line">            if(c&gt;1000000007)&#123;</span><br><span class="line">                c-&#x3D;1000000007;</span><br><span class="line">            &#125;</span><br><span class="line">            a&#x3D;b;</span><br><span class="line">            b&#x3D;c;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-10-II 青蛙跳台阶问题(斐波拉契数列)</title>
    <url>/2020/07/24/%E5%89%91-10-II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>
<p>提示：<br>0 &lt;= n &lt;= 100</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>跳上n级的跳法 F(n)=F(n-1)+F(n-2); 斐波拉契数列的一种。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numWays(int n) &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n&#x3D;&#x3D;2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int a&#x3D;1;</span><br><span class="line">        int b&#x3D;2;</span><br><span class="line">        int c&#x3D;0;</span><br><span class="line">        for(int i&#x3D;3;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            c&#x3D;a+b;</span><br><span class="line">            if(c&gt;1000000007)&#123;</span><br><span class="line">                c-&#x3D;1000000007;</span><br><span class="line">            &#125;</span><br><span class="line">            a&#x3D;b;</span><br><span class="line">            b&#x3D;c;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-11 旋转数组的最小数字</title>
    <url>/2020/07/24/%E5%89%91-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minArray(vector&lt;int&gt;&amp; numbers) &#123;</span><br><span class="line">        int a&#x3D;numbers[0];</span><br><span class="line">        int m&#x3D;numbers.size()-1;</span><br><span class="line">        if(numbers[m]&gt;a)&#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">        while(1)&#123;</span><br><span class="line">            if(m&#x3D;&#x3D;0)&#123;</span><br><span class="line">                return a;  </span><br><span class="line">            &#125;</span><br><span class="line">            if(numbers[m]&gt;&#x3D;numbers[m-1])&#123;</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                a&#x3D;numbers[m];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-12 矩阵中的路径(DFS)</title>
    <url>/2020/07/24/%E5%89%91-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a>矩阵中的路径</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;],</span><br><span class="line">[&quot;s&quot;,&quot;f&quot;,&quot;c&quot;,&quot;s&quot;],</span><br><span class="line">[&quot;a&quot;,&quot;d&quot;,&quot;e&quot;,&quot;e&quot;]]</span><br></pre></td></tr></table></figure>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>提示：1 &lt;= board.length &lt;= 200, 1 &lt;= board[i].length &lt;= 200</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答:"></a>解答:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dxy &#x3D; &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;&#x2F;&#x2F;方向矩阵</span><br><span class="line">    int rows, cols;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;bool&gt;&amp; visit, int i, int j, string&amp; word, int idx)&#123;</span><br><span class="line">        if(board[i][j] !&#x3D; word[idx]) return false;&#x2F;&#x2F;判断处理</span><br><span class="line">        </span><br><span class="line">        idx++;</span><br><span class="line">         if(idx &#x3D;&#x3D; word.size()) return  true;</span><br><span class="line">         visit[i*cols+j] &#x3D; true;&#x2F;&#x2F;标记访问</span><br><span class="line">        for(auto xy : dxy)&#123;  &#x2F;&#x2F;</span><br><span class="line">            int x &#x3D; xy[0] + i;</span><br><span class="line">            int y &#x3D; xy[1] + j;</span><br><span class="line">            if(x &lt; 0 || x &gt;&#x3D; rows || y &lt; 0 || y &gt;&#x3D; cols || visit[x*cols+y]) continue;&#x2F;&#x2F;边界判断和访问标记判断</span><br><span class="line">            else&#123;</span><br><span class="line">                if(dfs(board, visit, x, y, word, idx)) return true;进一步深搜</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i*cols+j] &#x3D; false;&#x2F;&#x2F;取消标记</span><br><span class="line">       </span><br><span class="line">        return false;&#x2F;&#x2F;本次搜索无效</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;</span><br><span class="line">        if(word &#x3D;&#x3D; &quot;&quot;)  return false;</span><br><span class="line">        rows &#x3D; board.size();</span><br><span class="line">        cols &#x3D; board[0].size();</span><br><span class="line">        vector&lt;bool&gt; visit(rows * cols, false);&#x2F;&#x2F;标记访问矩阵</span><br><span class="line">        for(int i &#x3D; 0;i &lt; rows; i++)&#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; cols; j++)&#123;</span><br><span class="line">                if(board[i][j] &#x3D;&#x3D; word[0])&#123;</span><br><span class="line">                    if(dfs(board, visit, i, j, word, 0)) return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-13 机器人的运动范围(DFS+BFS)</title>
    <url>/2020/07/24/%E5%89%91-13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h3 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a>机器人的运动范围</h3><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>提示：1 &lt;= n,m &lt;= 100; 0 &lt;= k &lt;= 20</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答:"></a>解答:</h3><p><strong>DFS:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">   vector&lt;vector&lt;int&gt;&gt; dxy &#x3D; &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">      void dfs( int x, int y, int m, int n, int&amp; count, vector&lt;int&gt;&amp; vec, int k )&#123;</span><br><span class="line">       if ( x &#x2F; 10 + x % 10 + y &#x2F; 10 + y % 10 &gt; k )&#x2F;&#x2F;一些判断</span><br><span class="line">            return;</span><br><span class="line">        if(x&lt;0 || x&gt;m-1 || y&lt;0 || y&gt;n-1 || vec[x*n+y]&#x3D;&#x3D;1)</span><br><span class="line">                return;</span><br><span class="line">      </span><br><span class="line">        vec[x*n+y]&#x3D;1;&#x2F;&#x2F;标记 一些操作</span><br><span class="line">        ++count;   </span><br><span class="line">        for(vector&lt;int&gt; xy:dxy)&#123; </span><br><span class="line">            int x1&#x3D;x+xy[0];</span><br><span class="line">            int y1&#x3D;y+xy[1];</span><br><span class="line">            dfs(x1, y1, m, n, count, vec, k ); &#x2F;&#x2F;深搜   </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    int movingCount(int m, int n, int k) &#123;</span><br><span class="line">      int count&#x3D;0;</span><br><span class="line">        vector&lt;int&gt; sign ( m*n, 0 );&#x2F;&#x2F;访问标记数组</span><br><span class="line">        dfs(0,0,m,n,count,sign,k);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>BFS:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dxy &#x3D; &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    int movingCount(int m, int n, int k) &#123;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        vector&lt;bool&gt; sign(m*n,false);&#x2F;&#x2F;标记访问数组</span><br><span class="line">        </span><br><span class="line">        queue&lt;pair&lt;int,int&gt;&gt; q;&#x2F;&#x2F;初始点</span><br><span class="line">        q.push(make_pair(0,0));</span><br><span class="line">        sign[0]&#x3D;true;</span><br><span class="line"></span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            pair&lt;int,int&gt; tmp&#x3D;q.front();&#x2F;&#x2F;取出</span><br><span class="line">            q.pop();  </span><br><span class="line">                count++;&#x2F;&#x2F;一些操作</span><br><span class="line">                </span><br><span class="line">            for(auto xy : dxy)&#123;</span><br><span class="line">                int x&#x3D;tmp.first+xy[0];</span><br><span class="line">                int y&#x3D;tmp.second+xy[1];</span><br><span class="line">                &#x2F;&#x2F;相邻合法且未访问过的点</span><br><span class="line">                if(x&gt;&#x3D;0 &amp;&amp; x&lt;m &amp;&amp; y&gt;&#x3D;0 &amp;&amp; y&lt;n &amp;&amp; sign[x*n+y]!&#x3D;true &amp;&amp; x &#x2F; 10 + x % 10 + y &#x2F; 10 + y % 10 &lt;&#x3D;k)&#123;</span><br><span class="line">                    q.push(make_pair(x,y));</span><br><span class="line">                    sign[x*n+y]&#x3D;true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-14-I 剪绳子</title>
    <url>/2020/07/24/%E5%89%91-14-I-%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<h3 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a>剪绳子</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure>
<p>提示：2 &lt;= n &lt;= 58</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答:"></a>解答:</h3><p><strong>方法一:</strong></p>
<p>1.任取长度为n的绳子，我们可以切最多n-1刀，现在考虑切的第一刀，有n-1种切法</p>
<p>2.那么用dp[n]表示长度为n的绳子可以产生的最大乘积.由1可知，<label style="color:red">dp[n] = max(dp[i]*dp[n-i])</label>,i属于[1,n-1]初始化边界是本题比较狗血的，因为i = 2,3的时候，本身dp的结果为1,2.但是计算其他节点时，他们的值应该取2 3.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cuttingRope(int n) &#123;</span><br><span class="line">        if(n &lt; 3) return 1;</span><br><span class="line">        if(n &#x3D;&#x3D; 3) return 2;</span><br><span class="line">        vector&lt;int&gt; dp(n+1,1);</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;n;i++) dp[i]&#x3D;i;&#x2F;&#x2F;目的主要是2,3俩个的设置,其他的随意初始化</span><br><span class="line">        </span><br><span class="line">        for(int i&#x3D;4;i&lt;&#x3D;n;i++)&#123;&#x2F;&#x2F;对4以后的dp进行计算.</span><br><span class="line">        </span><br><span class="line">            for(int j&#x3D;1;j&lt;4;j++)    &#x2F;&#x2F; j表示左侧绳子长度 ，这里当j&gt;&#x3D;4时，比如5 最大值为2*3&#x3D;6是一定要剪的，其他大于5的数同理</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] &#x3D; max(dp[i],dp[j]*dp[i-j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>方法二</strong></p>
<p>由方法一知,最大的话应该分成只含有2,3的相乘,又2* 2* 2小于3*3,所以最后就会余下俩个或一个2.</p>
<p>所以尽可能分3余下一个2,如果余下1则少一个3凑成俩个2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cuttingRope(int n) &#123;</span><br><span class="line">        if(n&lt;2)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n&#x3D;&#x3D;2)</span><br><span class="line">            return 1;</span><br><span class="line">        if(n&#x3D;&#x3D;3)</span><br><span class="line">            return 2;</span><br><span class="line">        int t3&#x3D;n&#x2F;3;&#x2F;&#x2F;算有几个3</span><br><span class="line">        if(n-t3*3&#x3D;&#x3D;1)&#x2F;&#x2F;余数为1,则改为4</span><br><span class="line">            t3-&#x3D;1;</span><br><span class="line">        int t2&#x3D;(n-t3*3)&#x2F;2;&#x2F;&#x2F;算有几个2</span><br><span class="line">        return pow(3,t3)*pow(2,t2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-15  二进制中1的个数</title>
    <url>/2020/07/25/%E5%89%91-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure>


<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p><strong>方法一：</strong>一个数 n 与一个比它小 1 的数（n−1）进行与运算（&amp;）之后，得到的结果会消除 n 中最低位的 1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1: 7 &amp; 6</span><br><span class="line">00111  &#x2F;&#x2F;7</span><br><span class="line">      &amp;   &#x3D;》 00110</span><br><span class="line">00110  &#x2F;&#x2F;6</span><br><span class="line"></span><br><span class="line">示例2: 8 &amp; 7</span><br><span class="line">01000  &#x2F;&#x2F;8</span><br><span class="line">      &amp;   &#x3D;》 00000</span><br><span class="line">00111  &#x2F;&#x2F;7</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line">        while (n !&#x3D; 0) &#123;</span><br><span class="line">            n &amp;&#x3D; n-1;</span><br><span class="line">            ret ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>方法二：</strong>按位判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingWeight(uint32_t n) &#123;</span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 32; i ++) &#123;</span><br><span class="line">            if (n &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">                ret ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-14-II 剪绳子 II</title>
    <url>/2020/07/25/%E5%89%91-14-II-%E5%89%AA%E7%BB%B3%E5%AD%90-II/</url>
    <content><![CDATA[<h3 id="剪绳子-II"><a href="#剪绳子-II" class="headerlink" title="剪绳子 II"></a>剪绳子 II</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure>

<p>提示：<br>2 &lt;= n &lt;= 1000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int cuttingRope(int n) &#123;</span><br><span class="line">    &#x2F;&#x2F;参考剪绳子一知，尽量分3.</span><br><span class="line">    &#x2F;&#x2F;2和3不能再分了  分了就变小了 且3优于2</span><br><span class="line">        if(n &lt;&#x3D; 3) return n-1;</span><br><span class="line">        long rs &#x3D; 1;</span><br><span class="line">        while (n &gt; 4) &#123;</span><br><span class="line">            &#x2F;&#x2F;3最优</span><br><span class="line">            rs *&#x3D; 3;</span><br><span class="line">            rs %&#x3D; 1000000007;&#x2F;&#x2F;商是多少，后面再乘不影响，余数再进行计算就是，相当于减了几个1000000007.</span><br><span class="line">            n -&#x3D; 3;</span><br><span class="line">        &#125;</span><br><span class="line"> 	return (rs * n) % 1000000007;</span><br><span class="line">        &#x2F;&#x2F;循环结束 只剩下1, 2 ,3,4   *1等于没有</span><br><span class="line">        &#x2F;&#x2F;2，3不能再分了</span><br><span class="line">        &#x2F;&#x2F;4 可以分成1 * 3  2 * 2,所以还是4最优</span><br><span class="line">        &#x2F;&#x2F;所以 剩下的1 2 3 4 都不能再分了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-16 数值的整数次方(递归)</title>
    <url>/2020/07/25/%E5%89%91-16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br></pre></td></tr></table></figure>
<p>解释: 2<sup>-2</sup>= = 1/2<sup>2</sup> = 1/4 = 0.25</p>
<p>说明: -100.0 &lt; x &lt; 100.0， n是32位有符号整数，其数值范围是 [−2<sup>31</sup>, 2<sup>31</sup> − 1] 。</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        double ans &#x3D; 0.0;</span><br><span class="line">        long num &#x3D; n;</span><br><span class="line">        if(n &lt; 0) num &#x3D; -num;</span><br><span class="line">        if(num &#x3D;&#x3D; 0) return 1;</span><br><span class="line">        ans &#x3D; myPow(x,num&gt;&gt;1);  &#x2F;&#x2F; num&#x2F;2次方计算</span><br><span class="line">        ans*&#x3D;ans;</span><br><span class="line">        if(num &amp; 1)&#x2F;&#x2F; 如果num&#x2F;2的余数为1 则再乘以一个x。</span><br><span class="line">            ans &#x3D; ans * x;</span><br><span class="line">        return n &gt; 0? ans:1.0&#x2F;ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-17 打印从1到最大的n位数(大数字符操作)</title>
    <url>/2020/07/25/%E5%89%91-17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h3 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h3><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>

<p>说明：<br>用返回一个整数列表来代替打印<br>n 为正整数</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>方法一：简单解法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printNumbers(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">		if (n &#x3D;&#x3D; 0) return res;</span><br><span class="line">		&#x2F;&#x2F;打印到数组中</span><br><span class="line">		for (int i&#x3D;1,max&#x3D;pow(10,n);i&lt;max;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			res.push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：大数解法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	vector&lt;int&gt; res;&#x2F;&#x2F;结果数组</span><br><span class="line">	vector&lt;int&gt; printNumbers(int n) &#123;</span><br><span class="line">		if (n &lt;&#x3D; 0) return res;        </span><br><span class="line">		</span><br><span class="line">		string number(n, &#39;0&#39;);&#x2F;&#x2F;创建一个能容纳最大值的字符数组，初始全部设置为0</span><br><span class="line">        </span><br><span class="line">		while (!Increment(number))&#x2F;&#x2F;设置数字</span><br><span class="line">		&#123;</span><br><span class="line">			saveNumber(number);&#x2F;&#x2F;保存数字</span><br><span class="line">		&#125;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	bool Increment(string&amp; number) &#123;&#x2F;&#x2F;注意要使用引用传递，否则无法修改number</span><br><span class="line">		</span><br><span class="line">		bool isOverflow &#x3D; false;&#x2F;&#x2F;检测是否越界</span><br><span class="line">		int nTakeOver &#x3D; 0;&#x2F;&#x2F;存储进位</span><br><span class="line">		int nLength &#x3D; number.size();</span><br><span class="line">		for (int i &#x3D; nLength - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">		&#123;</span><br><span class="line">			int nSum &#x3D; number[i] - &#39;0&#39; + nTakeOver;</span><br><span class="line">			if (i &#x3D;&#x3D; nLength - 1)&#x2F;&#x2F;如果是第一位，加一。只在低位加一次</span><br><span class="line">			&#123;</span><br><span class="line">				nSum++;</span><br><span class="line">			&#125;</span><br><span class="line">			if (nSum &gt;&#x3D; 10)&#x2F;&#x2F;有进位</span><br><span class="line">			&#123;</span><br><span class="line">				if (i &#x3D;&#x3D; 0)&#x2F;&#x2F;如果是最高位有进位，说明超过了给定得到最大值，越界		</span><br><span class="line">				&#123;</span><br><span class="line">					isOverflow &#x3D; true;&#x2F;&#x2F;越界，停止。可以写return true;</span><br><span class="line">				&#125;</span><br><span class="line">				else</span><br><span class="line">				&#123;</span><br><span class="line">					nTakeOver &#x3D; 1;</span><br><span class="line">					number[i] &#x3D; nSum - 10 + &#39;0&#39;;&#x2F;&#x2F;对第i位进行设置</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#x2F;&#x2F;没有进位</span><br><span class="line">				&#x2F;&#x2F;设置第i位数字</span><br><span class="line">				&#x2F;&#x2F;并直接跳出循环</span><br><span class="line">			&#123;</span><br><span class="line">				number[i] &#x3D; nSum + &#39;0&#39;;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return isOverflow;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	void saveNumber(string number)	</span><br><span class="line">	&#123;</span><br><span class="line">		string s &#x3D; &quot;&quot;;</span><br><span class="line">		bool isBegin0 &#x3D; true;&#x2F;&#x2F;标记</span><br><span class="line">		string::iterator it &#x3D; number.begin();&#x2F;&#x2F;迭代器开始点</span><br><span class="line">		while (it !&#x3D; number.end())</span><br><span class="line">		&#123;</span><br><span class="line">			if (isBegin0 &amp;&amp; *it !&#x3D; &#39;0&#39;) isBegin0 &#x3D; false;&#x2F;&#x2F;找到第一个不为0的字符</span><br><span class="line">			if (!isBegin0)&#x2F;&#x2F;开始组合字符</span><br><span class="line">			&#123;</span><br><span class="line">				s +&#x3D; *it;</span><br><span class="line">			&#125;</span><br><span class="line">			it++;</span><br><span class="line">		&#125;</span><br><span class="line">		int num &#x3D; stoi(s);&#x2F;&#x2F;转整数</span><br><span class="line">		res.push_back(num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-18 删除链表的节点</title>
    <url>/2020/07/26/%E5%89%91-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h3 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h3><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>

<p>说明：<br>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteNode(ListNode* head, int val) &#123;</span><br><span class="line">        ListNode*pre&#x3D;head;&#x2F;&#x2F;记录前一个节点</span><br><span class="line">        ListNode*curr&#x3D;head-&gt;next;&#x2F;&#x2F;记录当前节点</span><br><span class="line">        if(head-&gt;val&#x3D;&#x3D;val)return curr;</span><br><span class="line">        while(curr!&#x3D;NULL)&#123;</span><br><span class="line">            if(curr-&gt;val&#x3D;&#x3D;val)&#123;&#x2F;&#x2F;选定当前节点，并让前一个节点指向当前节点的下一个节点</span><br><span class="line">                pre-&gt;next&#x3D;curr-&gt;next;</span><br><span class="line">                return head;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;&#x2F;&#x2F;pre和curr同时后移</span><br><span class="line">                curr&#x3D;curr-&gt;next;</span><br><span class="line">                pre&#x3D;pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
















]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-19 正则表达式匹配(字符匹配)</title>
    <url>/2020/07/26/%E5%89%91-19/</url>
    <content><![CDATA[<h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h3><p>请实现一个函数用来匹配包含 ‘.’ 和 ‘*‘ 的正则表达式。模式中的字符 ‘.’ 表示任意一个字符，而 ‘*‘ 表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 “aaa” 与模式 “a.a” 和 “ab<em>ac</em>a” 匹配，但与 “aa.a” 和 “ab*a” 均不匹配。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br></pre></td></tr></table></figure>
<p>示例 4:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 5:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的  ‘*‘。</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isMatch(string s, string p) &#123;</span><br><span class="line">       if(p.empty()) return s.empty();&#x2F;&#x2F;判断p是否为空，根据s是否空输出</span><br><span class="line">        if(p[1] &#x3D;&#x3D; &#39;*&#39;)&#123; &#x2F;&#x2F;p第二个字符是&#39;*&#39;考虑如下几种情况</span><br><span class="line">		&#x2F;&#x2F; 1，直接讲s与p[2]进行匹配</span><br><span class="line">		&#x2F;&#x2F; 2，s不为空且第一个字符匹配了，则将s[1]与p再匹配。注：因为&#39;*&#39;可以任意数量，所s[1]还是与p匹配</span><br><span class="line">        </span><br><span class="line">            return isMatch(s, p.substr(2)) || (!s.empty() &amp;&amp; (s[0] &#x3D;&#x3D; p[0] || p[0] &#x3D;&#x3D; &#39;.&#39;)) &amp;&amp;  isMatch(s.substr(1), p);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;&#x2F;&#x2F; p第二个字符不是&#39;*&#39;，则p和s各自后移一个再匹配</span><br><span class="line">            return !s.empty() &amp;&amp; (s[0] &#x3D;&#x3D; p[0] || p[0] &#x3D;&#x3D; &#39;.&#39;) &amp;&amp; (isMatch(s.substr(1), p.substr(1)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>注意点：</p>
<p><label style="color:red"> &amp;&amp; 运算优先级高于 || 运算</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p&#x3D;&quot;123455&quot;;</span><br><span class="line">p.substr(2) &#x2F;&#x2F;p&#x3D;&quot;3455&quot;;从2开始截取</span><br><span class="line">s.substr(0,5); &#x2F;&#x2F;获得字符串s中从第0位开始的长度为5的字符串</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-20 表示数值的字符串(字符串API)</title>
    <url>/2020/07/26/%E5%89%91-20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a>表示数值的字符串</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串 “+100” 、 “5e2” 、 “-123” 、 “3.1416” 、 “0123” 都表示数值，     但”12e”、”1a3.14”、”1.2.3”、”+-5”、”-1E-16”及”12e+5.4”都不是。</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isNumber(string s) &#123;</span><br><span class="line">        &#x2F;&#x2F;1、从首尾寻找s中不为空格首尾位置，也就是去除首尾空格</span><br><span class="line">        int i&#x3D;s.find_first_not_of(&#39; &#39;);</span><br><span class="line">        if(i&#x3D;&#x3D;string::npos)return false;</span><br><span class="line">        int j&#x3D;s.find_last_not_of(&#39; &#39;);</span><br><span class="line">        s&#x3D;s.substr(i,j-i+1);</span><br><span class="line">        if(s.empty())return false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2、根据e来划分底数和指数</span><br><span class="line">        int e&#x3D;s.find(&#39;e&#39;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;3、指数为空，判断底数</span><br><span class="line">        if(e&#x3D;&#x3D;string::npos)return judgeP(s);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;4、指数不为空，判断底数和指数</span><br><span class="line">        else return judgeP(s.substr(0,e))&amp;&amp;judgeS(s.substr(e+1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool judgeP(string s)&#x2F;&#x2F;判断底数是否合法</span><br><span class="line">    &#123;</span><br><span class="line">        bool result&#x3D;false,point&#x3D;false;</span><br><span class="line">        int n&#x3D;s.size();</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]&#x3D;&#x3D;&#39;+&#39;||s[i]&#x3D;&#x3D;&#39;-&#39;)&#123;&#x2F;&#x2F;符号位不在第一位，返回false</span><br><span class="line">                if(i!&#x3D;0)return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(s[i]&#x3D;&#x3D;&#39;.&#39;)&#123;</span><br><span class="line">                if(point)return false;&#x2F;&#x2F;有多个小数点，返回false</span><br><span class="line">                point&#x3D;true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(s[i]&lt;&#39;0&#39;||s[i]&gt;&#39;9&#39;)&#123;&#x2F;&#x2F;非纯数字，返回false</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                result&#x3D;true;&#x2F;&#x2F;有纯数字存在才会result变为true，不然没数字是false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool judgeS(string s)&#x2F;&#x2F;判断指数是否合法</span><br><span class="line">    &#123;   </span><br><span class="line">        bool result&#x3D;false;</span><br><span class="line">        &#x2F;&#x2F;注意指数不能出现小数点，所以出现除符号位的非纯数字表示指数不合法</span><br><span class="line">        for(int i&#x3D;0;i&lt;s.size();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(s[i]&#x3D;&#x3D;&#39;+&#39;||s[i]&#x3D;&#x3D;&#39;-&#39;)&#123;&#x2F;&#x2F;符号位不在第一位，返回false</span><br><span class="line">                if(i!&#x3D;0)return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(s[i]&lt;&#39;0&#39;||s[i]&gt;&#39;9&#39;)&#123;&#x2F;&#x2F;非纯数字，返回false</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                result&#x3D;true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：<label style="color:red"> string:npos是个特殊值</label>，说明查找没有匹配</p>
<p>查找字符串a是否包含子串b,不是用strA.find(strB) &gt; 0 而是 strA.find(strB) != string:npos</p>
]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-21 调整数组顺序使奇数位于偶数前面(前后指针遍历交换)</title>
    <url>/2020/07/28/%E5%89%91-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p> </p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>提示：<br>1 &lt;= nums.length &lt;= 50000, 1 &lt;= nums[i] &lt;= 10000</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       &#x2F;&#x2F;俩个指针，一个从前一个从后，互相交换</span><br><span class="line">       </span><br><span class="line">        int m&#x3D;0;int n&#x3D;nums.size()-1;</span><br><span class="line">        while(m&lt;n)&#123;</span><br><span class="line">            if(nums[m]%2&#x3D;&#x3D;1)&#123;</span><br><span class="line">                m++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums[n]%2&#x3D;&#x3D;0)&#123;</span><br><span class="line">                n--;</span><br><span class="line">                 continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(m!&#x3D;n)&#123;</span><br><span class="line">                int tmp&#x3D;nums[m];</span><br><span class="line">                nums[m]&#x3D;nums[n];</span><br><span class="line">                nums[n]&#x3D;tmp;</span><br><span class="line">                &#x2F;&#x2F;swap(nums[m],nums[n]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-22 链表中倒数第k个节点(俩个指针相距k同时移动)</title>
    <url>/2020/07/28/%E5%89%91-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h3><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* getKthFromEnd(ListNode* head, int k) &#123;</span><br><span class="line">         ListNode *p &#x3D; head, *q &#x3D; head; &#x2F;&#x2F;初始化</span><br><span class="line">        while(k--) &#123;   &#x2F;&#x2F;将 p指针移动 k 次</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(p !&#x3D; nullptr) &#123;&#x2F;&#x2F;同时移动，直到 p &#x3D;&#x3D; nullptr</span><br><span class="line">            p &#x3D; p-&gt;next;</span><br><span class="line">            q &#x3D; q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>















]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-25 合并两个排序的链表</title>
    <url>/2020/07/28/%E5%89%91-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<p>限制：<br>0 &lt;= 链表长度 &lt;= 1000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"> class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode* head &#x3D; new ListNode(1);&#x2F;&#x2F;不知道l1 l2是否为空，所以自己创建一个节点</span><br><span class="line">        ListNode* ret &#x3D; head;</span><br><span class="line">        while (l1 !&#x3D; NULL &amp;&amp; l2 !&#x3D; NULL) &#123;</span><br><span class="line">            if (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                head-&gt;next &#x3D; l1;</span><br><span class="line">                l1 &#x3D; l1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                head-&gt;next &#x3D; l2;</span><br><span class="line">                l2 &#x3D; l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head &#x3D; head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next &#x3D; l1 &#x3D;&#x3D; NULL ? l2 : l1;&#x2F;&#x2F; l1 为空？为空赋值l2,否则赋值l1</span><br><span class="line">        return ret-&gt;next;&#x2F;&#x2F;创建节点的下一个节点开始就是合并的链表</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>递归：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        if (l1 &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            return l2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l2 &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (l1-&gt;val &lt;&#x3D; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next &#x3D; mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            return l1;</span><br><span class="line">        &#125;</span><br><span class="line">        l2-&gt;next &#x3D; mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>























]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-24 反转链表(双指针)</title>
    <url>/2020/07/28/%E5%89%91-23-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p> </p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>限制：<br>0 &lt;= 节点个数 &lt;= 5000</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">        ListNode* p&#x3D;NULL,*q&#x3D;head;&#x2F;&#x2F;双指针，依次交换</span><br><span class="line">        while(q!&#x3D;NULL)&#123;</span><br><span class="line">            ListNode* tmp&#x3D;q-&gt;next;</span><br><span class="line">            q-&gt;next&#x3D;p;</span><br><span class="line">            p&#x3D;q;</span><br><span class="line">            q&#x3D;tmp;</span><br><span class="line">        &#125; </span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;递归方式</span><br><span class="line">&#x2F;&#x2F; class Solution &#123;</span><br><span class="line">&#x2F;&#x2F; public:</span><br><span class="line">&#x2F;&#x2F;     ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">&#x2F;&#x2F;         if (head &#x3D;&#x3D; NULL || head-&gt;next &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">&#x2F;&#x2F;             return head;</span><br><span class="line">&#x2F;&#x2F;         &#125;</span><br><span class="line">&#x2F;&#x2F;         ListNode* ret &#x3D; reverseList(head-&gt;next);&#x2F;&#x2F;递归到最底层</span><br><span class="line">&#x2F;&#x2F;         head-&gt;next-&gt;next &#x3D; head;&#x2F;&#x2F;指针转向，后面的指向本身</span><br><span class="line">&#x2F;&#x2F;         head-&gt;next &#x3D; NULL;&#x2F;&#x2F;本身指向空</span><br><span class="line">&#x2F;&#x2F;         return ret;</span><br><span class="line">&#x2F;&#x2F;     &#125;</span><br><span class="line">&#x2F;&#x2F; &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-26 树的子结构</title>
    <url>/2020/07/30/%E5%89%91-26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<p>例如:</p>
<p>给定的树 A:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   2</span><br></pre></td></tr></table></figure>
<p>给定的树 B：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   4 </span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure>
<p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,2,3], B &#x3D; [3,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [3,4,5,1,2], B &#x3D; [4,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>限制：<br>0 &lt;= 节点个数 &lt;= 10000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool helper(TreeNode* A, TreeNode* B) &#123;&#x2F;&#x2F;判断节点值是否相等，并对左右子树值进行判断</span><br><span class="line">        if (A &#x3D;&#x3D; NULL || B &#x3D;&#x3D; NULL) &#123;&#x2F;&#x2F;递归结束条件</span><br><span class="line">            return B &#x3D;&#x3D; NULL ? true : false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (A-&gt;val !&#x3D; B-&gt;val) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(A-&gt;left, B-&gt;left) &amp;&amp; helper(A-&gt;right, B-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    bool isSubStructure(TreeNode* A, TreeNode* B) &#123;</span><br><span class="line">        if (A &#x3D;&#x3D; NULL || B &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B);</span><br><span class="line">        &#x2F;&#x2F; 判断A B是否对应相等||A的左子树。。。||A的右子树。。。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-27 二叉树的镜像</title>
    <url>/2020/07/30/%E5%89%91-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h3 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>镜像输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p>限制：<br>0 &lt;= 节点个数 &lt;= 1000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>方法一：递归</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mirrorTree(TreeNode* root) &#123;&#x2F;&#x2F;树的镜像</span><br><span class="line">        if(root&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; if(root-&gt;left&#x3D;&#x3D;NULL&amp;&amp;root-&gt;right&#x3D;&#x3D;NULL)&#123;</span><br><span class="line">        &#x2F;&#x2F;     return root;</span><br><span class="line">        &#x2F;&#x2F; &#125;</span><br><span class="line">        TreeNode *tmp&#x3D;root-&gt;left;</span><br><span class="line">        root-&gt;left&#x3D;mirrorTree(root-&gt;right);&#x2F;&#x2F;右子树镜像给左子树</span><br><span class="line">        root-&gt;right&#x3D;mirrorTree(tmp);&#x2F;&#x2F;左子树镜像给右子树</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mirrorTree(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        s.push(root);&#x2F;&#x2F;根节点</span><br><span class="line">        while (!s.empty()) &#123;</span><br><span class="line">            TreeNode* node &#x3D; s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            if (node &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(node-&gt;left, node-&gt;right);&#x2F;&#x2F;交换左右子树节点</span><br><span class="line">            s.push(node-&gt;left); &#x2F;&#x2F;左右子树节点放进去，再交换他们的左右节点。</span><br><span class="line">            s.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-28 对称的二叉树</title>
    <url>/2020/07/30/%E5%89%91-28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h3><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br></pre></td></tr></table></figure>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>限制：<br>0 &lt;= 节点个数 &lt;= 1000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>方法一：递归</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        bool res &#x3D; true;</span><br><span class="line">        if (root!&#x3D;NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            res &#x3D; helper(root-&gt;left,root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool helper(TreeNode*A, TreeNode* B)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 先写递归终止条件</span><br><span class="line">        if (A&#x3D;&#x3D;NULL &amp;&amp; B&#x3D;&#x3D;NULL)</span><br><span class="line">            return true;</span><br><span class="line">        &#x2F;&#x2F; 如果其中之一为空，也不是对称的</span><br><span class="line">        if (A&#x3D;&#x3D;NULL || B&#x3D;&#x3D;NULL)</span><br><span class="line">            return false;</span><br><span class="line">        &#x2F;&#x2F; 走到这里二者一定不为空</span><br><span class="line">        if (A-&gt;val !&#x3D; B-&gt;val)</span><br><span class="line">            return false;</span><br><span class="line">        &#x2F;&#x2F; 前序遍历</span><br><span class="line">        return helper(A-&gt;left,B-&gt;right) &amp;&amp; helper(A-&gt;right,B-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D;NULL)</span><br><span class="line">            return true;</span><br><span class="line">        &#x2F;&#x2F;用队列保存节点</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        &#x2F;&#x2F;将根节点的左右孩子放到队列中</span><br><span class="line">        q.push(root-&gt;left);</span><br><span class="line">        q.push(root-&gt;right);</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;从队列中取出两个节点，再比较这两个节点</span><br><span class="line">            TreeNode* A &#x3D; q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            TreeNode* B &#x3D; q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            &#x2F;&#x2F;如果两个节点都为空就继续循环，两者有一个为空就返回false</span><br><span class="line">            if (A&#x3D;&#x3D;NULL &amp;&amp; B&#x3D;&#x3D;NULL)</span><br><span class="line">                continue;</span><br><span class="line">            if (A&#x3D;&#x3D;NULL || B&#x3D;&#x3D;NULL)</span><br><span class="line">                return false;</span><br><span class="line">            if (A-&gt;val !&#x3D; B-&gt;val)</span><br><span class="line">                return false;</span><br><span class="line">            &#x2F;&#x2F;将左子树的左孩子， 右子树的右孩子放入队列</span><br><span class="line">            q.push(A-&gt;left);</span><br><span class="line">            q.push(B-&gt;right);</span><br><span class="line">            &#x2F;&#x2F;将左子树的右孩子，右子树的左孩子放入队列</span><br><span class="line">            q.push(A-&gt;right);</span><br><span class="line">            q.push(B-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-29 顺时针打印矩阵</title>
    <url>/2020/07/30/%E5%89%91-29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h3 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<p>限制：<br>0 &lt;= matrix.length &lt;= 100, 0 &lt;= matrix[i].length &lt;= 100</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     &#x2F;&#x2F; 表示方向:→、↓、←、↑</span><br><span class="line">    vector&lt;int&gt; di &#x3D; &#123;0,1,0,-1&#125;; </span><br><span class="line">    vector&lt;int&gt; dj &#x3D; &#123;1,0,-1,0&#125;;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        &#x2F;&#x2F;空值情况处理</span><br><span class="line">        vector&lt;int&gt; Res;</span><br><span class="line">        if(!matrix.size()) return Res;</span><br><span class="line">        if(!matrix[0].size()) return Res;</span><br><span class="line"></span><br><span class="line">        int row &#x3D; matrix.size(),col &#x3D; matrix[0].size();</span><br><span class="line">        int num &#x3D; row*col;      &#x2F;&#x2F;矩阵元素个数</span><br><span class="line">        int x &#x3D; 0, y&#x3D;0 ;        &#x2F;&#x2F;待访问元素坐标</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; flag(row,vector&lt;int&gt;(col,1)); &#x2F;&#x2F;是否访问过该数组</span><br><span class="line">        int k &#x3D; 0;              &#x2F;&#x2F;遍历方向        </span><br><span class="line">        while(Res.size()&lt; num)&#123;</span><br><span class="line">            if( 0&lt;&#x3D; x &amp;&amp; x&lt;row &amp;&amp; 0&lt;&#x3D; y &amp;&amp; y&lt;col &amp;&amp; flag[x][y])&#123;</span><br><span class="line">                Res.push_back(matrix[x][y]);</span><br><span class="line">                flag[x][y]&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;               &#x2F;&#x2F;越界则回溯一个值，然后换个方向继续走</span><br><span class="line">                x-&#x3D;di[k]; y-&#x3D;dj[k];</span><br><span class="line">                k&#x3D;(++k)%4;</span><br><span class="line">            &#125;</span><br><span class="line">            x+&#x3D;di[k]; y+&#x3D;dj[k];</span><br><span class="line">        &#125;</span><br><span class="line">        return Res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
















]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-30 包含min函数的栈</title>
    <url>/2020/07/30/%E5%89%91-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h3 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p> <br>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>各函数的调用总次数不超过 20000 次</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;** initialize your data structure here. *&#x2F;</span><br><span class="line">    stack&lt;int&gt; s_data;&#x2F;&#x2F;存放数据</span><br><span class="line">	stack&lt;int&gt; s_min;&#x2F;&#x2F;存放每一次压入后，栈内的最小值</span><br><span class="line">    MinStack() &#123;   </span><br><span class="line">    &#125;</span><br><span class="line">    void push(int x) &#123;&#x2F;&#x2F;压栈，添加数据</span><br><span class="line">        s_data.push(x);&#x2F;&#x2F;正常添加数据</span><br><span class="line">		if (s_min.size() &#x3D;&#x3D; 0) s_min.push(x);</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			if (x &lt; s_min.top()) s_min.push(x);&#x2F;&#x2F;添加的数据比min_stack顶部元素小则把数据加入</span><br><span class="line">			else s_min.push(s_min.top());&#x2F;&#x2F;否则，将压入一个和顶部元素相同的数据</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; </span><br><span class="line">    void pop() &#123;&#x2F;&#x2F;每次pop 俩个栈都弹出数据</span><br><span class="line">        if (s_data.size() &#x3D;&#x3D; 0) return;</span><br><span class="line">		s_data.pop();</span><br><span class="line">		s_min.pop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    int top() &#123;&#x2F;&#x2F;数据顶部元素</span><br><span class="line">        return s_data.top();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    int min() &#123;&#x2F;&#x2F;最小元素</span><br><span class="line">         return s_min.top();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Your MinStack object will be instantiated and called as such:</span><br><span class="line"> * MinStack* obj &#x3D; new MinStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * obj-&gt;pop();</span><br><span class="line"> * int param_3 &#x3D; obj-&gt;top();</span><br><span class="line"> * int param_4 &#x3D; obj-&gt;min();</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>






















]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-31 栈的压入、弹出序列</title>
    <url>/2020/07/30/%E5%89%91-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; pushed.length &#x3D;&#x3D; popped.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; pushed[i], popped[i] &lt; 1000</span><br><span class="line">pushed 是 popped 的排列。</span><br></pre></td></tr></table></figure>

<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123;</span><br><span class="line">        stack&lt;int&gt; st;&#x2F;&#x2F;栈</span><br><span class="line">        int n &#x3D; popped.size();</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; pushed.size(); ++i)&#123;</span><br><span class="line">            st.push(pushed[i]);压入数据</span><br><span class="line">            while(!st.empty() &amp;&amp; j &lt; n &amp;&amp; st.top() &#x3D;&#x3D; popped[j])&#123;</span><br><span class="line">                st.pop();&#x2F;&#x2F;根据弹出序列，对应相等则弹出</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return st.empty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-32-II 从上到下打印二叉树 II</title>
    <url>/2020/07/30/%E5%89%91-32-II-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-II/</url>
    <content><![CDATA[<h3 id="从上到下打印二叉树-II"><a href="#从上到下打印二叉树-II" class="headerlink" title="从上到下打印二叉树 II"></a>从上到下打印二叉树 II</h3><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p> </p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>提示：<br>节点总数 &lt;= 1000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">         vector&lt;vector&lt;int&gt;&gt; vec;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        if(root&#x3D;&#x3D;NULL)</span><br><span class="line">            return vec;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int now&#x3D;1;</span><br><span class="line">        int future&#x3D;0;</span><br><span class="line"></span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            TreeNode* tmp&#x3D;q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            v.push_back(tmp-&gt;val);</span><br><span class="line">            if(tmp-&gt;left!&#x3D;NULL)&#123;</span><br><span class="line">                q.push(tmp-&gt;left);</span><br><span class="line">                future++;&#x2F;&#x2F;计算新加的数量</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            if(tmp-&gt;right!&#x3D;NULL)&#123;</span><br><span class="line">                q.push(tmp-&gt;right);</span><br><span class="line">                future++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            now--;&#x2F;&#x2F;统计取出的数量</span><br><span class="line">            if(now&#x3D;&#x3D;0)&#123;</span><br><span class="line">                vec.push_back(v);</span><br><span class="line">                &#x2F;&#x2F; &#123;</span><br><span class="line">                &#x2F;&#x2F;     std::vector&lt;int&gt; tt;   </span><br><span class="line">                &#x2F;&#x2F;     v.swap(tt);</span><br><span class="line">                &#x2F;&#x2F; &#125; </span><br><span class="line">                &#x2F;&#x2F;&#x2F;&#x2F;v.clear();</span><br><span class="line">                vector&lt;int&gt;().swap(v);</span><br><span class="line">                now&#x3D;future;&#x2F;&#x2F;下一层的数量</span><br><span class="line">                future&#x3D;0;&#x2F;&#x2F;重置数量</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>动态数组的清空方式。<br>   vector<int>().swap(ivec); 或者如下所示 加一对大括号都可以，意思一样的：<br>     {<br>      std::vector<int> tmp;<br>      ivec.swap(tmp);<br>     }<br>   v.clear();</p>
]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-32-I 从上到下打印二叉树(按层次打印，队列queue)</title>
    <url>/2020/07/30/%E5%89%91-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<p> </p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure>

<p>提示：<br>节点总数 &lt;= 1000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        vector&lt;int&gt; v;</span><br><span class="line">        if(root&#x3D;&#x3D;NULL)</span><br><span class="line">            return v;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            TreeNode* tmp&#x3D;q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            v.push_back(tmp-&gt;val);</span><br><span class="line">            if(tmp-&gt;left!&#x3D;NULL)</span><br><span class="line">                q.push(tmp-&gt;left);</span><br><span class="line">            if(tmp-&gt;right!&#x3D;NULL)</span><br><span class="line">                q.push(tmp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-32-III 从上到下打印二叉树 III(双头队列deque)</title>
    <url>/2020/07/30/%E5%89%91-32-III-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-III/</url>
    <content><![CDATA[<h3 id="从上到下打印二叉树-III"><a href="#从上到下打印二叉树-III" class="headerlink" title="从上到下打印二叉树 III"></a>从上到下打印二叉树 III</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p> </p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<p>节点总数 &lt;= 1000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        vector&lt;int&gt; out;</span><br><span class="line">        if (root&#x3D;&#x3D;NULL)</span><br><span class="line">            return res;</span><br><span class="line">        bool flag &#x3D; true; &#x2F;&#x2F;从左向右打印为true，从右向左打印为false</span><br><span class="line">        deque&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push_back(root);</span><br><span class="line">        while (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            int n &#x3D; q.size();</span><br><span class="line">           </span><br><span class="line">            TreeNode* node;</span><br><span class="line">            while (n&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                if (flag) &#x2F;&#x2F; 前取后放：从左向右打印，所以从前边取，后边放入</span><br><span class="line">                &#123;</span><br><span class="line">                    node &#x3D; q.front();</span><br><span class="line">                    q.pop_front();</span><br><span class="line">                    if (node-&gt;left)</span><br><span class="line">                        q.push_back(node-&gt;left);  &#x2F;&#x2F; 下一层顺序存放至尾</span><br><span class="line">                    if (node-&gt;right)</span><br><span class="line">                        q.push_back(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                else  &#x2F;&#x2F;后取前放： 从右向左，从后边取，前边放入</span><br><span class="line">                &#123;</span><br><span class="line">                    node &#x3D; q.back();</span><br><span class="line">                    q.pop_back();</span><br><span class="line">                    if (node-&gt;right)</span><br><span class="line">                        q.push_front(node-&gt;right);  &#x2F;&#x2F; 下一层逆序存放至首</span><br><span class="line">                    if (node-&gt;left)</span><br><span class="line">                        q.push_front(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                out.push_back(node-&gt;val);</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            flag &#x3D; !flag;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">            out.clear();&#x2F;&#x2F;vector&lt;int&gt;().swap(out);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-33 二叉搜索树的后序遍历序列</title>
    <url>/2020/07/30/%E5%89%91-33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<p> </p>
<p>参考以下这颗二叉搜索树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提示：<br>数组长度 &lt;= 1000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p><label style="color:red"> 什么是二叉查找树：<br>根节点的值大于其左子树中任意一个节点的值，小于其右子树中任意一节点的值</label></p>
<p>思路：树先序中序后序，均看成三个区间进行处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">bool verifyPostorder(vector&lt;int&gt;&amp; postorder) &#123;</span><br><span class="line">      if (0 &#x3D;&#x3D; postorder.size())</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return process(postorder, 0, int(postorder.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool process(vector&lt;int&gt;&amp; postorder, int begin, int end)</span><br><span class="line">    &#123;</span><br><span class="line">        int i &#x3D; begin;</span><br><span class="line">        for (; i &lt; end-1; ++i)&#x2F;&#x2F;区分左，右，根，三个区间</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;找到第一个比根大的</span><br><span class="line">            if (postorder.at(i) &gt; postorder.at(end-1))</span><br><span class="line">            &#123;  </span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;在右子树区域中找是否有小于根的</span><br><span class="line">        &#x2F;&#x2F;左区间不处理是因为之前遍历已经确定比根小了</span><br><span class="line">        int j&#x3D;i;</span><br><span class="line">        for (; j &lt; end-1; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            if (postorder.at(j) &lt; postorder.at(end-1))</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">			</span><br><span class="line">        &#x2F;&#x2F;对左右子树在进行处理   </span><br><span class="line">        bool left&#x3D;true;</span><br><span class="line">        if(i&gt;begin)</span><br><span class="line">            left&#x3D;process(postorder,begin,i);</span><br><span class="line">        </span><br><span class="line">        bool right&#x3D;true;</span><br><span class="line">        if(i&lt;end-1)</span><br><span class="line">            right&#x3D;process(postorder,i,end-1);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;递归处理 左、右子树</span><br><span class="line">        return left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-34 二叉树中和为某一值的路径(DES)</title>
    <url>/2020/07/30/%E5%89%91-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h3><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p> </p>
<p>示例:<br>给定如下二叉树，以及目标和 sum = 22，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>
<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>提示：<br>节点总数 &lt;= 10000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>注：dfs+回溯</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    &#x2F;&#x2F;回溯算法</span><br><span class="line">    void dfs(TreeNode* root,int sum)&#123;</span><br><span class="line">        if(root&#x3D;&#x3D;nullptr) return;</span><br><span class="line">        &#x2F;&#x2F;先序遍历</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        sum -&#x3D; root-&gt;val;</span><br><span class="line">        if(sum &#x3D;&#x3D; 0 &amp;&amp; root-&gt;left &#x3D;&#x3D;nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr)&#123;&#x2F;&#x2F;满足条件将路径添加进去</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left,sum);</span><br><span class="line">        dfs(root-&gt;right,sum);</span><br><span class="line">        path.pop_back();&#x2F;&#x2F;最后回溯，等同于标记</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123;</span><br><span class="line">        dfs(root,sum);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-36 二叉搜索树与双向链表</title>
    <url>/2020/07/30/%E5%89%91-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>
<p> </p>
<p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p>
<p><img src="/img/7.png">
 </p>
<p> </p>
<p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>
<p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。<br><img src="/img/8.png">
 </p>
<p> </p>
<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>问题分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设：有任意结点 r</span><br><span class="line">step 1 将r的左子树变为有序链表，要输出此有序链表的头尾结点 Lhead、LTail；</span><br><span class="line">step 2 将r的右子树变为有序链表，要输出此有序链表的头尾结点 Rhead、RTail；</span><br><span class="line">step 3 将r结点与左有序链表和右有序两边连接；即将Ltail结点与r-&gt;left连接；将r-&gt;right 与 Rhead与其连接；</span><br><span class="line">step 4 返回以r结点为根的树的头与尾 ：Lhead、RTail</span><br><span class="line">截止条件：r 为叶子结点</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">&#x2F;&#x2F; Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line"></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val &#x3D; _val;</span><br><span class="line">        left &#x3D; NULL;</span><br><span class="line">        right &#x3D; NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(int _val, Node* _left, Node* _right) &#123;</span><br><span class="line">        val &#x3D; _val;</span><br><span class="line">        left &#x3D; _left;</span><br><span class="line">        right &#x3D; _right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* treeToDoublyList(Node* root) &#123;</span><br><span class="line">        if(!root) return nullptr;</span><br><span class="line">        Node* head &#x3D; nullptr, *pre &#x3D; nullptr;</span><br><span class="line">        helper(root, head, pre);&#x2F;&#x2F;返回以root为根的树的双向链表的头尾</span><br><span class="line">        head-&gt;left &#x3D; pre;</span><br><span class="line">        pre-&gt;right &#x3D; head;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    void helper(Node* root, Node*&amp; head, Node*&amp; pre) &#123;&#x2F;&#x2F; 左，中，右</span><br><span class="line">        if(!root)  return;</span><br><span class="line">        helper(root-&gt;left, head, pre);&#x2F;&#x2F;左边处理完</span><br><span class="line">        if(!head) &#123;</span><br><span class="line">            head &#x3D; root;   &#x2F;&#x2F; 找到head</span><br><span class="line">            pre &#x3D; root;    &#x2F;&#x2F; 对pre进行初始化</span><br><span class="line">        &#125; else &#123;&#x2F;&#x2F;连接根节点</span><br><span class="line">            pre-&gt;right &#x3D; root;</span><br><span class="line">            root-&gt;left &#x3D; pre;</span><br><span class="line">            pre &#x3D; root;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root-&gt;right, head, pre);&#x2F;&#x2F;处理右边，右子树的最左边开始与之前的一起处理</span><br><span class="line">        &#x2F;&#x2F;二叉搜索树的排序顺序处理的</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-37 序列化二叉树(istringstream,ostringstream)</title>
    <url>/2020/07/31/%E5%89%91-37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>示例: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你可以将以下二叉树：</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">序列化为 &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>

<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Codec &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Encodes a tree to a single string.</span><br><span class="line">    string serialize(TreeNode* root) &#123;&#x2F;&#x2F;按层次打印二叉树</span><br><span class="line">        ostringstream out;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            TreeNode* tmp &#x3D; q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            if (tmp) &#123;</span><br><span class="line">                out&lt;&lt;tmp-&gt;val&lt;&lt;&quot; &quot;;</span><br><span class="line">                q.push(tmp-&gt;left);</span><br><span class="line">                q.push(tmp-&gt;right);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                out&lt;&lt;&quot;null &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return out.str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Decodes your encoded data to tree.</span><br><span class="line">    TreeNode* deserialize(string data) &#123;</span><br><span class="line">        istringstream input(data);</span><br><span class="line">        string val;</span><br><span class="line">        vector&lt;TreeNode*&gt; vec;</span><br><span class="line">        while (input &gt;&gt; val) &#123;&#x2F;&#x2F;字符流 创建节点存进数组中</span><br><span class="line">            if (val &#x3D;&#x3D; &quot;null&quot;) &#123;</span><br><span class="line">                vec.push_back(NULL);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                vec.push_back(new TreeNode(stoi(val)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int j &#x3D; 1;                                          &#x2F;&#x2F; i每往后移动一位，j移动两位，j始终是当前i的左子下标</span><br><span class="line">        for (int i &#x3D; 0; j &lt; vec.size(); ++i) &#123;              &#x2F;&#x2F; 肯定是j先到达边界，所以这里判断j &lt; vec.size()</span><br><span class="line">            if (vec[i] &#x3D;&#x3D; NULL) continue;                   &#x2F;&#x2F; vec[i]为null时跳过。</span><br><span class="line">            if (j &lt; vec.size()) vec[i]-&gt;left &#x3D; vec[j++];    &#x2F;&#x2F; 当前j位置为i的左子树</span><br><span class="line">            if (j &lt; vec.size()) vec[i]-&gt;right &#x3D; vec[j++];   &#x2F;&#x2F; 当前j位置为i的右子树</span><br><span class="line">        &#125;</span><br><span class="line">        return vec[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Your Codec object will be instantiated and called as such:</span><br><span class="line">&#x2F;&#x2F; Codec codec;</span><br><span class="line">&#x2F;&#x2F; codec.deserialize(codec.serialize(root));</span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-35 复杂链表的复制(分离法，哈希表)</title>
    <url>/2020/07/30/%E5%89%91-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h3 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h3><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<p> </p>
<p>示例 1：</p>
<p><img src="/img/4.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<p><img src="/img/5.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<p><img src="/img/6.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-10000 &lt;&#x3D; Node.val &lt;&#x3D; 10000</span><br><span class="line">Node.random 为空（null）或指向链表中的节点。</span><br><span class="line">节点数目不超过 1000 。</span><br></pre></td></tr></table></figure>

<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>解题思路：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 分解法</span><br><span class="line"> *</span><br><span class="line"> * A-&gt;A&#39;-&gt;B-&gt;B&#39;-&gt;C-&gt;C&#39;-&gt;D-&gt;D&#39;-&gt;E-&gt;E&#39;</span><br><span class="line"> * |_____R|_______|R    |      |R</span><br><span class="line"> *        |_____________|______|</span><br><span class="line"> *        |_____________|</span><br><span class="line"> *</span><br><span class="line"> * 1. 根据原链表的value和next对原链表进行复制，</span><br><span class="line"> *    复制的节点在原节点之后，此步未处理random指针</span><br><span class="line"> * 2. 遍历链表，复制每个节点的random指针</span><br><span class="line"> * 3. 将复制后的链表拆分为原链表和复制链表。</span><br><span class="line"> * *&#x2F;</span><br></pre></td></tr></table></figure>

<p>代码实现：</p>
<p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">&#x2F;&#x2F; Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">public:</span><br><span class="line">    int val;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node* random;</span><br><span class="line">    </span><br><span class="line">    Node(int _val) &#123;</span><br><span class="line">        val &#x3D; _val;</span><br><span class="line">        next &#x3D; NULL;</span><br><span class="line">        random &#x3D; NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        </span><br><span class="line">         if(head&#x3D;&#x3D;NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">        Node* head1&#x3D;head;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;复制备份所有节点</span><br><span class="line">        while(head1!&#x3D;NULL)&#x2F;&#x2F;复制的节点在原节点之后，此步未处理random指针</span><br><span class="line">        &#123;</span><br><span class="line">            Node* newnode&#x3D;new Node(head1-&gt;val);</span><br><span class="line">            newnode-&gt;next&#x3D;head1-&gt;next;</span><br><span class="line">            head1-&gt;next&#x3D;newnode;</span><br><span class="line">            head1&#x3D;newnode-&gt;next;&#x2F;&#x2F;移动节点指针</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;更新每个备份节点的指针指向</span><br><span class="line">        head1&#x3D;head;</span><br><span class="line">        while(head1!&#x3D;NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* randmnode&#x3D;head1-&gt;random;</span><br><span class="line">            if (head1-&gt;random!&#x3D;NULL)&#x2F;&#x2F;一定要判断是否为空，只有非空节点才能操作，切记</span><br><span class="line">				head1-&gt;next-&gt;random &#x3D; randmnode-&gt;next;</span><br><span class="line">                &#x2F;&#x2F;randmnode是原本节点的指向，randmnode-&gt;next是原本指向节点的拷贝</span><br><span class="line">                &#x2F;&#x2F;A的random指向D，head1-&gt;next-&gt;random代表A&#39;的random，randmnode-&gt;next代表D&#39;。</span><br><span class="line">            head1&#x3D;head1-&gt;next-&gt;next;&#x2F;&#x2F;移动节点指针，一次性跳跃两个节点</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;分离两个链表</span><br><span class="line">        head1&#x3D;head;</span><br><span class="line">        Node* head2&#x3D;head-&gt;next;</span><br><span class="line">        Node* tmp&#x3D;head2;</span><br><span class="line">        while(1)</span><br><span class="line">        &#x2F;&#x2F;A指向B并移到B</span><br><span class="line">        &#x2F;&#x2F;A&#39;指向B&#39;并移到B&#39;</span><br><span class="line">        &#123;</span><br><span class="line">            head1-&gt;next&#x3D;tmp-&gt;next;&#x2F;&#x2F;head1：A，指向A&#39;的next B</span><br><span class="line">            head1&#x3D;head1-&gt;next;&#x2F;&#x2F;head1：B</span><br><span class="line"></span><br><span class="line">            if(head1&#x3D;&#x3D;NULL)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            tmp-&gt;next&#x3D;head1-&gt;next;&#x2F;&#x2F;tmp：A&#39;，指向B的next B&#39;</span><br><span class="line">            tmp&#x3D;tmp-&gt;next;&#x2F;&#x2F;tmp：B&#39;</span><br><span class="line">        &#125;</span><br><span class="line">        return head2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：哈希表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        if(head&#x3D;&#x3D;NULL)  return head;</span><br><span class="line">        unordered_map&lt;Node*,Node*&gt;mp;</span><br><span class="line">        Node *t&#x3D;head;</span><br><span class="line">        while(t!&#x3D;NULL)&#123;&#x2F;&#x2F;哈希表复制存储</span><br><span class="line">            mp[t]&#x3D;new Node(t-&gt;val);</span><br><span class="line">            t&#x3D;t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        t&#x3D;head;</span><br><span class="line">        while(t!&#x3D;NULL)&#123;</span><br><span class="line">            if(t-&gt;next)&#123;&#x2F;&#x2F;next指针处理</span><br><span class="line">                mp[t]-&gt;next&#x3D;mp[t-&gt;next];</span><br><span class="line">            &#125;</span><br><span class="line">            if(t-&gt;random)&#123;&#x2F;&#x2F;random指针处理</span><br><span class="line">                mp[t]-&gt;random&#x3D;mp[t-&gt;random];</span><br><span class="line">            &#125;</span><br><span class="line">            t&#x3D;t-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return mp[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-38 字符串的排列(dfs)</title>
    <url>/2020/07/31/%E5%89%91-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h3><p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p> </p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p> </p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>

<p>限制：</p>
<p>1 &lt;= s 的长度 &lt;= 8</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    vector&lt;string&gt; permutation(string s) &#123;</span><br><span class="line">        dfs(s, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(string&amp; s, int pos) &#123;</span><br><span class="line">        if (pos &gt;&#x3D; s.size()) &#123;</span><br><span class="line">            result.push_back(s);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; pos; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            if (judge(s, pos, i)) continue;   &#x2F;&#x2F; 如果pos和i之间有字符等于s[i]，则跳过。</span><br><span class="line">            swap(s[pos], s[i]);&#x2F;&#x2F;第一个位置所有情况都取到</span><br><span class="line">            dfs(s, pos+1);&#x2F;&#x2F;利用交换位置使得第一个位置取到所有不同值，然后再对第二个位置进行处理</span><br><span class="line">            swap(s[pos], s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool judge(string&amp; s, int start, int end) &#123;</span><br><span class="line">        for (int i &#x3D; start; i &lt; end; ++i) &#123;</span><br><span class="line">            if (s[i] &#x3D;&#x3D; s[end]) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-40 最小的k个数(大根堆)</title>
    <url>/2020/07/31/%E5%89%91-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h3 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h3><p>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p>限制：<br>0 &lt;= k &lt;= arr.length &lt;= 10000, 0 &lt;= arr[i] &lt;= 10000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>方法一：排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; vec(k, 0);</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        for (int i &#x3D; 0; i &lt; k; ++i) vec[i] &#x3D; arr[i];</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：利用大根堆，最大优先队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;</span><br><span class="line">        vector&lt;int&gt;vec(k, 0);</span><br><span class="line">        if (k &#x3D;&#x3D; 0) return vec; &#x2F;&#x2F; 排除 0 的情况</span><br><span class="line">        priority_queue&lt;int&gt;Q;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; k; ++i) Q.push(arr[i]);&#x2F;&#x2F;往最大优先队列先放入k个数</span><br><span class="line">        for (int i &#x3D; k; i &lt; arr.size(); ++i) &#123;&#x2F;&#x2F;剩余的数组中的数，与队列中的最大值进行比较</span><br><span class="line">            if (Q.top() &gt; arr[i]) &#123;&#x2F;&#x2F;比队列最大值小，则替换进去</span><br><span class="line">                Q.pop();</span><br><span class="line">                Q.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; k; ++i) &#123;</span><br><span class="line">            vec[i] &#x3D; Q.top();</span><br><span class="line">            Q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-39 数组中出现次数超过一半的数字</title>
    <url>/2020/07/31/%E5%89%91-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p> </p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>限制：<br>1 &lt;= 数组长度 &lt;= 50000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>方法一：按照位进行操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">            int ans &#x3D; 0;</span><br><span class="line">            int n &#x3D; nums.size();</span><br><span class="line">            for(int i&#x3D;0; i &lt; 32; i++)&#123;</span><br><span class="line">              int cnt &#x3D; 0;</span><br><span class="line">              for(int n: nums)&#123;</span><br><span class="line">                if(n &amp; 1 &lt;&lt; i) cnt ++;</span><br><span class="line">              &#125;</span><br><span class="line">              if(cnt &gt; n &#x2F; 2) ans ^&#x3D; 1 &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法二：排序后中间的元素一定是出现超过一半的数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        return nums[nums.size()&#x2F;2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法三：哈希表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt;mp;</span><br><span class="line">        for(auto it : nums)&#123;</span><br><span class="line">            mp[it]++;</span><br><span class="line">            if(mp[it]&gt;nums.size()&#x2F;2) return it;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法四：超过一半的数字比其他所有数字的总和次数多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n&#x3D;1;</span><br><span class="line">        int result&#x3D;nums[0];</span><br><span class="line">        for(int i&#x3D;1;i&lt;nums.size();i++)&#123;</span><br><span class="line">            if(n&#x3D;&#x3D;0)&#123;</span><br><span class="line">                result&#x3D;nums[i];</span><br><span class="line">                n&#x3D;1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(result&#x3D;&#x3D;nums[i])n++;</span><br><span class="line">            else n--;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-41 数据流中的中位数(大小根堆)</title>
    <url>/2020/07/31/%E5%89%91-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h3 id="数据流中的中位数"><a href="#数据流中的中位数" class="headerlink" title="数据流中的中位数"></a>数据流中的中位数</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。<br>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,2.00000,null,2.50000]</span><br></pre></td></tr></table></figure>

<p>限制：</p>
<p>最多会对 addNum、findMedia进行 50000 次调用。</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>中位数，左边的数放在大根堆中，右边的数放在小根堆中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 优先队列实现（注意“优先队列”用法类似stack，和普通队列不一样）</span><br><span class="line">class MedianFinder &#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;** initialize your data structure here. *&#x2F;</span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addNum(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        int grossSum &#x3D; mMax.size() + mMin.size();</span><br><span class="line">        if(grossSum &amp; 1)&#123;</span><br><span class="line">        &#x2F;&#x2F;奇数(小根堆比大根堆多一个)，num比小根堆top小，则直接放进大根堆。</span><br><span class="line">        &#x2F;&#x2F;比小根堆top大，则把top放进大根堆，把num放进小根堆</span><br><span class="line">            if(!mMin.empty() &amp;&amp; num &gt; mMin.top())&#123;</span><br><span class="line">                int temp &#x3D; mMin.top();</span><br><span class="line">                mMin.pop();</span><br><span class="line">                mMin.push(num);</span><br><span class="line">                num &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">            mMax.push(num);</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F;偶数(小根堆和大根堆一样多)，num比大根堆top大，则直接放进小根堆</span><br><span class="line">        &#x2F;&#x2F;num比大根堆top小，则将大根堆的top放进小根堆，num放进大根堆。</span><br><span class="line">            if(!mMax.empty() &amp;&amp; num &lt; mMax.top())&#123;</span><br><span class="line">                int temp &#x3D; mMax.top();</span><br><span class="line">                mMax.pop();</span><br><span class="line">                mMax.push(num);</span><br><span class="line">                num &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">            mMin.push(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double findMedian()</span><br><span class="line">    &#123;</span><br><span class="line">        int grossSum &#x3D; mMax.size() + mMin.size();</span><br><span class="line">        if(grossSum &amp; 1)</span><br><span class="line">            return (double)(mMin.top());&#x2F;&#x2F;奇数个，中位数在mMin里</span><br><span class="line">        else</span><br><span class="line">            return (double)(mMax.top() + mMin.top()) &#x2F; 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    &#x2F;&#x2F; 注意这里less默认最大堆，而greater是最小堆。</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; mMax;     &#x2F;&#x2F; 大根堆，最大优先队列</span><br><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; mMin;  &#x2F;&#x2F; 小根堆，#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="line"> * MedianFinder* obj &#x3D; new MedianFinder();</span><br><span class="line"> * obj-&gt;addNum(num);</span><br><span class="line"> * double param_2 &#x3D; obj-&gt;findMedian();</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-42 连续子数组的最大和(用 dp[i] 表示以 nums[i] 结尾的最大和)</title>
    <url>/2020/08/01/%E5%89%91-42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<p> </p>
<p>示例1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<p>提示：1 &lt;= arr.length &lt;= 10^5, -100 &lt;= arr[i] &lt;= 100</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>思路描述：动态规划，用 dp[i] 表示以 nums[i] 结尾的最大和，那么可以得出递推表达式 dp[i] = max(dp[i - 1] + nums[i], nums[i])</p>
<p>因为如果以 nums[i - 1] 结尾的最大和加上 nums[i] 的值小于 nums[i] 的值，那么以 nums[i] 结尾的最大和肯定是 nums[i] 了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ans &#x3D; INT_MIN;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(), 0);</span><br><span class="line">        dp[0] &#x3D; nums[0];</span><br><span class="line">        ans &#x3D; max(ans, dp[0]);</span><br><span class="line">        for (int i &#x3D; 1; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            dp[i] &#x3D; dp[i - 1] &gt; 0 ? (nums[i] + dp[i - 1]) : nums[i];</span><br><span class="line">            ans &#x3D; max(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(nums.size(), nums[0]);</span><br><span class="line">        int ans &#x3D; dp[0];</span><br><span class="line">        for(int i &#x3D; 1; i &lt; nums.size(); i ++)&#123;</span><br><span class="line">            dp[i] &#x3D; max(dp[i - 1] + nums[i], nums[i]);</span><br><span class="line">            ans &#x3D; max(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为都是只用到了 dp[i - 1] 去更新 dp[i]，那么可以直接使用一个变量去替换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int dp &#x3D; nums[0];</span><br><span class="line">        int ans &#x3D; dp;</span><br><span class="line">        for(int i &#x3D; 1; i &lt; nums.size(); i ++)&#123;</span><br><span class="line">            dp &#x3D; max(dp + nums[i], nums[i]);</span><br><span class="line">            ans &#x3D; max(ans, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-43 1～n整数中1出现的次数</title>
    <url>/2020/08/01/%E5%89%91-43-1%EF%BD%9En%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h3 id="1～n整数中1出现的次数"><a href="#1～n整数中1出现的次数" class="headerlink" title="1～n整数中1出现的次数"></a>1～n整数中1出现的次数</h3><p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p>限制：<br>1 &lt;= n &lt; 2^31</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>第i个位置出现 1 的次数</p>
<p>================================================<br>具体思路：<br>因为是要求所有情况下1出现的次数，所以可以将该问题分解成每个位置上1出现的次数，最后将每个位置上出现的次数求和。<br>假设i为数字n从低到高的第i位，比第i位高的称为高位，比第i位低的称为低位。分情况讨论第i位置上的数。</p>
<p>====当i位置上的数字大于1时<br>第i位置大于1，此时低位部分的每一个位置都可以取到0-9，所以次数为<br>(高位数字大小+1)*10^(i-1)<br>上述公式中加1是高位全0的情况</p>
<p>======当i位置上的数字等于1时<br>此时分成两种情况讨论</p>
<p>高位取最大值数值。这时低位部分的每个位置不能取到0-9，低位的个数为 低位数字大小+1。<br>因此1出现的次数为 1 * (低位数字大小+1)。加1也是全为0的情况。<br>高位不取最大值。这时低位部分是可取到0-9的，所以1出现的次数为 （高位数字大小-1+1)*10^(i-1)<br>综上，当i位置上的数字为1时，出现的总次数为：<br>高位数字大小 *10^(i-1)+低位数字大小+1</p>
<p>========当i位置上的数字为0时<br>这时i位置要想为1，就必须向高位借1，因此此时低位部分是都可以取到0-9的。所以次数为：<br>(高位数字大小-1+1) * 10^(i-1)=高位数字大小*10^(i-1)</p>
<p>方法一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countDigitOne(int n) &#123;</span><br><span class="line">       int count &#x3D; 0;</span><br><span class="line">       long i &#x3D; 1;&#x2F;&#x2F;指向遍历的位数，如i&#x3D;1即个位，i&#x3D;10即十位，...，因为n可以有31位，所以10^31用long存储</span><br><span class="line">       while(n&#x2F;i!&#x3D;0)&#123;</span><br><span class="line">           &#x2F;&#x2F;n&#x2F;i控制遍历的次数，将所有的位数都遍历完毕</span><br><span class="line">            long high &#x3D; n&#x2F;(10*i);&#x2F;&#x2F;将当前位之前的所有高位都存在high中</span><br><span class="line">            long cur &#x3D; (n&#x2F;i)%10;&#x2F;&#x2F;将当前位记录在cur中，即我们每次都需要统计当前位上1出现的次数</span><br><span class="line">            long low &#x3D; n-(n&#x2F;i)*i;</span><br><span class="line">            if(cur &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                count +&#x3D; high * i;</span><br><span class="line">            &#125; else if(cur &#x3D;&#x3D; 1)&#123;</span><br><span class="line">                count +&#x3D; high * i + low + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                count +&#x3D; high * i + i;</span><br><span class="line">            &#125;</span><br><span class="line">            i &#x3D; i * 10;&#x2F;&#x2F;准备遍历下一位</span><br><span class="line">       &#125;</span><br><span class="line">       return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int countDigitOne(int n) &#123;</span><br><span class="line">        string s &#x3D; to_string(n);</span><br><span class="line">        int length &#x3D; s.size();</span><br><span class="line">        int index &#x3D; 1;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        while(index&lt;&#x3D;length)&#123;&#x2F;&#x2F;从低位往高位遍历</span><br><span class="line">            int currentNum &#x3D; s[length-index] - &#39;0&#39;;</span><br><span class="line">            if(currentNum&gt;1)&#x2F;&#x2F;公式一：</span><br><span class="line">                count +&#x3D; (getDigitHigh(s,length,index)+1)*pow(10,index-1);</span><br><span class="line">            else if(currentNum &#x3D;&#x3D; 1)&#x2F;&#x2F;公式二：</span><br><span class="line">                count +&#x3D; (getDigitHigh(s,length,index)*pow(10,index-1)+getDigitLow(s,length,index)+1);</span><br><span class="line">            else&#x2F;&#x2F;公式三：</span><br><span class="line">                count +&#x3D; getDigitHigh(s,length,index)*pow(10,index-1);</span><br><span class="line">            index ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getDigitHigh(string s, int length, int currentLength)&#123; &#x2F;&#x2F;截取获取高位数字</span><br><span class="line">        s &#x3D; s.substr(0,length-currentLength);</span><br><span class="line">        if(s!&#x3D;&quot;\0&quot;)&#x2F;&#x2F;&quot;\0&quot;等同于&quot;&quot;</span><br><span class="line">            return stoi(s);</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getDigitLow(string s, int length, int currentLength)&#123;&#x2F;&#x2F;获取低位数字</span><br><span class="line">        s &#x3D; s.substr(length-currentLength+1);</span><br><span class="line">        if(s!&#x3D;&quot;\0&quot;)</span><br><span class="line">            return stoi(s);</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-45 把数组排成最小的数(sort改写，比较字符串)</title>
    <url>/2020/08/02/%E5%89%91-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h3 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h3><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure>

<p>提示:<br>0 &lt; nums.length &lt;= 100</p>
<p>说明:</p>
<p>输出结果可能非常大，所以你需要返回一个字符串而不是整数<br>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>我们这里说的排列大小比较和字符串大小有点区别，比如 3 和 30，明显 30 排在前面比较好，所以我们要重构比较，我们组合 s1 和 s2 ，如果 s1 + s2 &gt; s2 + s1，那么 s1 &gt; s2</p>
<p>方法一：直接改写sort</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool compare(string sa, string sb)</span><br><span class="line">    &#123;return sa+sb &lt; sb+sa;&#125;</span><br><span class="line">    </span><br><span class="line">    string minNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        &#x2F;&#x2F; 选取使字符串组合更小的排序规则</span><br><span class="line">        vector&lt;string&gt; tmp;</span><br><span class="line">        for(int n : nums)&#123;</span><br><span class="line">            tmp.push_back(to_string(n));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(tmp.begin(), tmp.end(), compare);</span><br><span class="line">        string ans &#x3D; &quot;&quot;;</span><br><span class="line">        for(string s : tmp) ans +&#x3D; s;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：匿名函数lambda表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string minNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        &#x2F;&#x2F; 选取使字符串组合更小的排序规则</span><br><span class="line">        &#x2F;&#x2F;auto compare &#x3D; [](string sa, string sb)&#123;return sa+sb &lt; sb+sa;&#125;;</span><br><span class="line">        vector&lt;string&gt; tmp;</span><br><span class="line">        for(int n : nums)&#123;</span><br><span class="line">            tmp.push_back(to_string(n));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(tmp.begin(), tmp.end(), [](string s1, string s2)&#123;return s1 + s2 &lt; s2 + s1;&#125;);</span><br><span class="line">        &#x2F;&#x2F;sort(tmp.begin(), tmp.end(), compare);</span><br><span class="line">        string ans &#x3D; &quot;&quot;;</span><br><span class="line">        for(string s : tmp) ans +&#x3D; s;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-44 数字序列中某一位的数字</title>
    <url>/2020/08/02/%E5%89%91-44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a>数字序列中某一位的数字</h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>
<p>请写一个函数，求任意第n位对应的数字。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 11</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p>限制：<br>0 &lt;= n &lt; 2^31</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p><img src="/img/9.png"></p>
<p>观察得除0外，个位数9个占0.9 * 10(1) *  1个位置，十位数90个占0.9* 10(2) * 2位置，百位数900个占0.9* 10(3)*3位置，依次类推。</p>
<p><strong>解题思想：</strong></p>
<p>可以根据n所在多少位，先求出n所在的数字；</p>
<p>再将该数字转化为字符串；</p>
<p>最后求出n在字符串的第几位并将该位输出即可。</p>
<p><strong>注意点：</strong></p>
<p>1： 本题解中主要处理个数的问题，每前进一段，就将上一段的长度给砍掉。</p>
<p>2： 题目中是从0开始到n的，也就是一开始有n+1个数。当取n = 0时，i也应该为0， 不满足循环公式（会出错），所以在while循环之前，单独处理了0段，即将n+1个数减1，表示去除了0段之后，还剩n个数。</p>
<p>3： <label style="color:red"> (n-1)/i 中的n-1是为了在求n所在数字时，低位从0开始。即，”564”第0个是5。</label>pow（10，i-1）是为了求n所在数字段的起始基础。<br>如从基础100开始，通过n-1可以保证从0开始计数，即100+n-1可以取到100，否则只能从101开始，取不到100，导致错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findNthDigit(int n) &#123;</span><br><span class="line">        int i &#x3D; 1;</span><br><span class="line">        while(n &gt; 0.9*pow(10,i)*i) n -&#x3D; 0.9*pow(10,i)*i,i++;            &#x2F;&#x2F;大于则前进</span><br><span class="line">        string res &#x3D; to_string(pow(10, i-1) + (n-1)&#x2F;i);                 &#x2F;&#x2F;求出n所在的数字，并转化位字符串</span><br><span class="line">        &#x2F;&#x2F;pow(10, i-1)是起始点，可以100代入理解，pow(10, i-1)起始100，而100-99后还有1。所以(n-1)&#x2F;i，用n-1。</span><br><span class="line">        return res[(n-1)%i] - &#39;0&#39;;                                      </span><br><span class="line">        &#x2F;&#x2F;求出n在第几位，输出。此处的n-1是因为字符从第0位开始的。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-46 把数字翻译成字符串(递归)</title>
    <url>/2020/08/03/%E5%89%91-46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提示：0 &lt;= num &lt; 2^31</p>
<h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><p>1.每次取最后两位数,rem = num % 100<br>2.若rem &gt; 25,则无法表示,即rem的个位和十位无法合一起，则用translateNum(num/10),表示前进一位<br>3.若在00 &lt;= rem &lt;= 09,则无法表示，即rem的个位和十位无法合一起，所以用translateNum(num/10)<br>如num = 506,其只有一种表示为fag,不可表示为fg，所以0是无法和6组合一起成为06<br>4.若在10 &lt;= rem &lt;= 25,则可以分出两种表示方法,所以用translateNum(num/10) + translateNum(num/100)递归来计算数量<br>5.所以总结以上就是：<br>if (num &lt; 10),则加1<br>if (num%100 &lt; 10 || num%100 &gt; 25) translateNum(num/10);<br>if (10 &lt;= num % 100 &lt;= 25) translateNum(num/10) + translateNum(num/100);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int translateNum(int num) &#123;</span><br><span class="line">        if (num &lt; 10) return 1;</span><br><span class="line">        return (num%100 &lt; 10 || num%100 &gt; 25) ? translateNum(num&#x2F;10) : translateNum(num&#x2F;10) + translateNum(num&#x2F;100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同一思路，实现方式差不多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int backtrack(string&amp; s, int idx)&#123;</span><br><span class="line">        int n &#x3D; s.size();</span><br><span class="line">        if(idx &#x3D;&#x3D; n) return 1;&#x2F;&#x2F;idx到n越界，结束。</span><br><span class="line">        </span><br><span class="line">         &#x2F;&#x2F;idx &#x3D;&#x3D; n - 1，因为只剩最后俩个数12时，1单独翻译只有一种方法。</span><br><span class="line">        &#x2F;&#x2F;所以到了最后一个元素n-1，不需要判断s.substr(idx, 2)。</span><br><span class="line">        </span><br><span class="line">        if(idx &#x3D;&#x3D; n - 1 || s[idx] &#x3D;&#x3D; &#39;0&#39; || s.substr(idx, 2) &gt; &quot;25&quot;)</span><br><span class="line">            return backtrack(s, idx + 1);</span><br><span class="line">        return backtrack(s, idx + 1) + backtrack(s, idx + 2);</span><br><span class="line">    &#125;</span><br><span class="line">    int translateNum(int num) &#123;</span><br><span class="line">        string s &#x3D; to_string(num);</span><br><span class="line">        return backtrack(s, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
















]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-48 最长不含重复字符的子字符串(哈希表)</title>
    <url>/2020/08/03/%E5%89%91-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h3><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p>提示：<br>s.length &lt;= 40000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>我们可以使用哈希表记录每个字符的下一个索引，然后尽量向右移动尾指针来拓展窗口，并更新窗口的最大长度。如果尾指针指向的元素重复，则将头指针直接移动到窗口中重复元素的右侧。</p>
<p><strong>算法</strong><br>tail 指针向末尾方向移动；<br>如果尾指针指向的元素存在于哈希表中：<br>head 指针跳跃到重复字符的下一位；<br>更新哈希表和窗口长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        map&lt;char, int&gt; m;</span><br><span class="line">        int ret &#x3D; 0, l &#x3D; 0, r &#x3D; 0;</span><br><span class="line">        while (r &lt; s.size()) &#123;</span><br><span class="line">        &#x2F;&#x2F;用find函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器.</span><br><span class="line">        &#x2F;&#x2F;如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器</span><br><span class="line">            if (m.find(s[r]) !&#x3D; m.end()) &#123;</span><br><span class="line">                l &#x3D; max(l, m[s[r]] + 1);&#x2F;&#x2F;更新左指针</span><br><span class="line">            &#125;</span><br><span class="line">            m[s[r]] &#x3D; r;&#x2F;&#x2F;哈希表更新</span><br><span class="line">            r++;</span><br><span class="line">            ret &#x3D; max(r - l, ret);更新窗口大小</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-49 丑数(合并三个有序序列)</title>
    <url>/2020/08/03/%E5%89%91-49-%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h3 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a>丑数</h3><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p> </p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>
<p>说明:   1 是丑数。n 不超过1690。</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>丑数的排列<br>假设当前存在 3 个数组 nums2, nums3, nums5 分别代表丑数序列从 1 开始分别乘以 2, 3, 5 的序列， 即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums2 &#x3D; &#123;1*2, 2*2, 3*2, 4*2, 5*2, 6*2, 8*2...&#125;</span><br><span class="line">nums3 &#x3D; &#123;1*3, 2*3, 3*3, 4*3, 5*3, 6*3, 8*3...&#125;</span><br><span class="line">nums5 &#x3D; &#123;1*5, 2*5, 3*5, 4*5, 5*5, 6*5, 8*5...&#125;</span><br><span class="line"># 注意 7 不是丑数. </span><br><span class="line"># 2, 3, 5 这前 3 个丑数一定要乘以其它的丑数， 所得的结果才是新的丑数， 所以上例中没有出现 7*2, 7*3, 7*5</span><br></pre></td></tr></table></figure>
<p>那么， 最终的丑数序列实际上就是这 3 个有序序列对的合并结果。</p>
<p>合并 3 个有序序列， 最简单的方法就是每一个序列都各自维护一个指针， 然后比较指针指向的元素的值， 将最小的放入最终的合并数组中， 并将相应指针向后移动一个元素。</p>
<p><label style="color:red"> nums2, nums3, nums5 中是存在重复的解的</label>， 例如 nums2[2] == 3<em>2, nums3[1] == 2</em>3 都计算出了 6 这个结果， 所以在合并 3 个有序数组的过程中， 还需要跳过相同的结果， 这也就是为什么在比较的时候， 需要使用 3 个并列的 if… if… if… 而不是 if… else if… else 这种结构的原因。 当比较到元素 6 时， if (dp[i] == dp[p2] * 2)…if (dp[i] == dp[p3] * 3)… 可以同时指向 nums2, nums3 中 元素 6 的下一个元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1, 2, 3, 4, 5, 6, 8, 9, 10, 12</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	int nthUglyNumber(int n) &#123;</span><br><span class="line">		vector&lt;int&gt; dp(n, 0);</span><br><span class="line">		dp[0] &#x3D; 1;</span><br><span class="line">		int p2 &#x3D; 0, p3 &#x3D; 0, p5 &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt; n; i++)&#123;</span><br><span class="line">			dp[i] &#x3D; min(min(dp[p2] * 2, dp[p3] * 3), dp[p5] * 5);</span><br><span class="line">			if (dp[i] &#x3D;&#x3D; dp[p2] * 2) </span><br><span class="line">                		p2++;</span><br><span class="line">			if (dp[i] &#x3D;&#x3D; dp[p3] * 3) </span><br><span class="line">                		p3++;</span><br><span class="line">			if (dp[i] &#x3D;&#x3D; dp[p5] * 5) </span><br><span class="line">                		p5++;</span><br><span class="line">		&#125;</span><br><span class="line">		return dp[n - 1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-47 礼物的最大价值(数组记忆搜索)</title>
    <url>/2020/08/03/%E5%89%91-47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<h3 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a>礼物的最大价值</h3><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure>

<p>提示：0 &lt; grid.length &lt;= 200, 0 &lt; grid[0].length &lt;= 200</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>迭代，记忆搜索，二维数组存储走到每个位置的最大值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int row &#x3D; grid.size();</span><br><span class="line">        int col &#x3D; grid[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res(row, vector&lt;int&gt;(col, 0));</span><br><span class="line">        for (int i &#x3D; 0; i &lt; row; ++i) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; col; ++j) &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0)</span><br><span class="line">                    res[i][j] &#x3D; grid[0][0];</span><br><span class="line">                else if (i &#x3D;&#x3D; 0)</span><br><span class="line">                    res[i][j] &#x3D; res[i][j - 1] + grid[i][j];</span><br><span class="line">                else if (j &#x3D;&#x3D; 0)</span><br><span class="line">                    res[i][j] &#x3D; res[i - 1][j] + grid[i][j];</span><br><span class="line">                else</span><br><span class="line">                    res[i][j] &#x3D; max(res[i - 1][j], res[i][j - 1]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[row - 1][col - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>状态表示：dp[i][j]表示到达i,j位置处的最大价值</p>
<p>转移方程：dp[i][j] = max{dp[i-1][j],dp[i][j-1]} + grid[i][j];</p>
<p>dp数组初始状态：dp[0][j] = {0}, dp[i][0] = {0} (就是将第一行和第一列全部设为0)</p>
<p>其实这里的dp数组我们可以将它优化成一维的，优化之后的一维dp保存的是当前上一行的最大价值，然后我们从做到有去更新这个数组即可</p>
<p>dp[0]一直是0，dp[i]存的是当前上一行最大值，dp[i-1]是dp[i]左侧最大值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">       int r &#x3D; grid.size(), c &#x3D; grid[0].size();</span><br><span class="line">        vector&lt;int&gt; dp(c+1,0);</span><br><span class="line">        for(int i &#x3D; 0; i &lt; r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; c; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j+1] &#x3D; max(dp[j],dp[j+1]) + grid[i][j];   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-50 第一个只出现一次的字符(哈希表)</title>
    <url>/2020/08/03/%E5%89%91-50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h3 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>限制：0 &lt;= s 的长度 &lt;= 50000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    char firstUniqChar(string s) &#123;</span><br><span class="line">         if(s &#x3D;&#x3D; &quot;&quot;)</span><br><span class="line">            return &#39; &#39;;</span><br><span class="line">        &#x2F;&#x2F;map中是对应字符出现的次数</span><br><span class="line">        unordered_map&lt;char,int&gt; cmap;</span><br><span class="line">        for(auto i &#x3D; 0;i &lt; s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cmap[s[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;按字符串的顺序在map中查找到第一个出现一次的字符</span><br><span class="line">        for(auto i &#x3D; 0;i &lt; s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cmap[s[i]] &#x3D;&#x3D; 1)</span><br><span class="line">                return s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;没有找到</span><br><span class="line">        return &#39; &#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-52 两个链表的第一个公共节点(AB，BA，拼接)</title>
    <url>/2020/08/03/%E5%89%91-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h3 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h3><p>输入两个链表，找出它们的第一个公共节点。</p>
<p>如下面的两个链表：</p>
<p><img src="/img/11.png"></p>
<p>在节点 c1 开始相交。</p>
<p>示例 1：</p>
<p><img src="/img/12.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line"></span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<p><img src="/img/13.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line"></span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<p><img src="/img/10.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line"></span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果两个链表没有交点，返回 null.</span><br><span class="line">在返回结果后，两个链表仍须保持原有的结构。</span><br><span class="line">可假定整个链表结构中没有循环。</span><br><span class="line">程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</span><br></pre></td></tr></table></figure>


<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p>
<p>这样，当它们相遇时，所指向的结点就是第一个公共结点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">         if (!headA || !headB)&#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA &#x3D; headA, *pB &#x3D; headB;</span><br><span class="line">        while (pA !&#x3D; pB) &#123;</span><br><span class="line">            pA &#x3D; pA &#x3D;&#x3D; nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB &#x3D; pB &#x3D;&#x3D; nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果链表相交，则链表公共节点都在尾部。</p>
<p>先计算两个链表长度。<br>让长链表指针先走多出长度，然后两个链表同时走，如果相遇则为相交节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">            if (!headA || !headB) return nullptr;</span><br><span class="line">            int len1 &#x3D; len(headA), len2 &#x3D; len(headB);        </span><br><span class="line">            if (len1 &gt;&#x3D; len2) &#123;&#x2F;&#x2F;让长链表指针先走多出长度</span><br><span class="line">                int move &#x3D; len1 - len2;</span><br><span class="line">                while (move--) &#123;</span><br><span class="line">                    headA &#x3D; headA-&gt;next;                </span><br><span class="line">                &#125;     </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int move &#x3D; len2 - len1;</span><br><span class="line">                while (move--) &#123;</span><br><span class="line">                    headB &#x3D; headB-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            while (headA !&#x3D; headB) &#123;&#x2F;&#x2F;两个链表同时走，如果相遇则为相交节点            </span><br><span class="line">                headA &#x3D; headA-&gt;next;</span><br><span class="line">                headB &#x3D; headB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            return headA;</span><br><span class="line">        &#125;</span><br><span class="line">	&#x2F;&#x2F;计算链表长度</span><br><span class="line">        int len(ListNode *head) &#123;</span><br><span class="line">            int len &#x3D; 0;</span><br><span class="line">            while (head) &#123;</span><br><span class="line">                ++len;</span><br><span class="line">                head &#x3D; head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            return len;</span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-51 数组中的逆序对(归并排序)</title>
    <url>/2020/08/03/%E5%89%91-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,5,6,4]</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<p>限制：0 &lt;= 数组长度 &lt;= 50000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p><label style="color:red"> 「归并排序」是分治思想的典型应用，它包含这样三个步骤：</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分解： 待排序的区间为[l,r]，令 m &#x3D;(l+r)&#x2F;2 ，我们把[l,r]分成[l,m]和[m+1,r]</span><br><span class="line">解决： 使用归并排序递归地排序两个子序列</span><br><span class="line">合并： 把两个已经排好序的子序列 [l, m][l,m] 和 [m + 1, r][m+1,r] 合并起来</span><br></pre></td></tr></table></figure>
<p>在待排序序列长度为 11 的时候，递归开始「回升」，因为我们默认长度为 11 的序列是排好序的。</p>
<p><label style="color:red">思路: </label></p>
<p>那么求逆序对和归并排序又有什么关系呢？关键就在于「归并」当中「并」的过程。我们通过一个实例来看看。假设我们有两个已排序的序列等待合并，分别是 L ={ 8, 12, 16, 22, 100 }和 R = R={9,26,55,64,91}。一开始我们用指针 lPtr = 0 指向 L 的首部，rPtr = 0 指向 R 的头部。记已经合并好的部分为 M。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; []</span><br><span class="line">     |                          |</span><br><span class="line">   lPtr                       rPtr</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们发现 lPtr 指向的元素小于 rPtr 指向的元素，于是把 lPtr 指向的元素放入答案，并把 lPtr 后移一位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8]</span><br><span class="line">        |                       |</span><br><span class="line">      lPtr                     rPtr</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接着我们继续合并，此时 lPtr 指向 12，rPtr指向的 9 小于12，则12到100都比9大，贡献为mid-i+1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [8, 12, 16, 22, 100]   R &#x3D; [9, 26, 55, 64, 91]  M &#x3D; [8, 9]</span><br><span class="line">        |                          |</span><br><span class="line">       lPtr                       rPtr</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong><label style="color:red"> 实现代码</label></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int reversePairs(vector&lt;int&gt;&amp; nums) &#123;           </span><br><span class="line">        vector&lt;int&gt; temp(nums.size(), 0);</span><br><span class="line">        int kk&#x3D;nums.size()-1;</span><br><span class="line">        sort(nums,0,kk,temp);</span><br><span class="line">        return this-&gt;count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void sort(vector&lt;int&gt;&amp; arr,int left,int right,vector&lt;int&gt;&amp; temp)&#123;</span><br><span class="line">        if(left&lt;right)&#123;</span><br><span class="line">            int mid &#x3D; (left+right)&#x2F;2;</span><br><span class="line">            sort(arr,left,mid,temp);&#x2F;&#x2F;左边归并排序，使得左子序列有序</span><br><span class="line">            sort(arr,mid+1,right,temp);&#x2F;&#x2F;右边归并排序，使得右子序列有序</span><br><span class="line">            merge(arr,left,mid,right,temp);&#x2F;&#x2F;将两个有序子数组合并操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void merge(vector&lt;int&gt;&amp; arr,int left,int mid,int right,vector&lt;int&gt;&amp; temp)&#123;</span><br><span class="line">        int i &#x3D; left;&#x2F;&#x2F;左序列指针</span><br><span class="line">        int j &#x3D; mid+1;&#x2F;&#x2F;右序列指针</span><br><span class="line">        int t &#x3D; 0;&#x2F;&#x2F;临时数组指针</span><br><span class="line">        while (i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;right)&#123;</span><br><span class="line">            if(arr[i]&lt;&#x3D;arr[j])&#123;</span><br><span class="line">                temp[t++] &#x3D; arr[i++];</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                temp[t++] &#x3D; arr[j++];</span><br><span class="line">                this-&gt;count&#x3D;this-&gt;count+mid-i+1;&#x2F;&#x2F;归并排序添加的一行,左侧i到mid的元素都比j的元素大。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(i&lt;&#x3D;mid)&#123;&#x2F;&#x2F;将左边剩余元素填充进temp中</span><br><span class="line">            temp[t++] &#x3D; arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        while(j&lt;&#x3D;right)&#123;&#x2F;&#x2F;将右序列剩余元素填充进temp中</span><br><span class="line">            temp[t++] &#x3D; arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;将temp中的元素全部拷贝到原数组中</span><br><span class="line">        while(left &lt;&#x3D; right)&#123;</span><br><span class="line">            arr[left++] &#x3D; temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-53-I 在排序数组中查找数字 I(lower_bound,upper_bound)</title>
    <url>/2020/08/04/%E5%89%91-53-I-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-I/</url>
    <content><![CDATA[<h3 id="在排序数组中查找数字-I"><a href="#在排序数组中查找数字-I" class="headerlink" title="在排序数组中查找数字 I"></a>在排序数组中查找数字 I</h3><p>统计一个数字在排序数组中出现的次数。</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p>限制：0 &lt;= 数组长度 &lt;= 50000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>方法一：遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            if(nums[i]&#x3D;&#x3D;target)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法二：利用两次二分法分别找到重复相同数字的左边界x和右边界y</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        if(nums.empty())return 0;</span><br><span class="line">        int n&#x3D;nums.size();</span><br><span class="line">        int left&#x3D;0,right&#x3D;n-1,mid;</span><br><span class="line">        int x;</span><br><span class="line">        int y;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            if(nums[mid]&gt;&#x3D;target)right&#x3D;mid;</span><br><span class="line">            else left&#x3D;mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[left]!&#x3D;target)return 0;</span><br><span class="line">        x&#x3D;left;&#x2F;&#x2F;第一个出现查找数值的位置</span><br><span class="line">        right&#x3D;n;</span><br><span class="line">        while(left&lt;right)&#123;&#x2F;&#x2F;第一个比查找数值大的位置</span><br><span class="line">            mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            if(nums[mid]&lt;&#x3D;target) left&#x3D;mid+1;</span><br><span class="line">            else right&#x3D;mid;</span><br><span class="line">        &#125;</span><br><span class="line">        y&#x3D;left;</span><br><span class="line">        return y-x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>方法三：lower_bound 与 upper_bound</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        </span><br><span class="line">     return upper_bound(nums.begin(), nums.end(), target) - lower_bound(nums.begin(), nums.end(), target);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; lower_bound(起始地址，结束地址，要查找的数值) 返回的是数值 第一个 出现的位置。第一个大于等于要查找的数值</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; upper_bound(起始地址，结束地址，要查找的数值) 返回的是数值 最后一个 出现的位置。第一个大于要查找的数值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-53-II 0～n-1中缺失的数字(二分法)</title>
    <url>/2020/08/04/%E5%89%91-53-II-0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="0～n-1中缺失的数字"><a href="#0～n-1中缺失的数字" class="headerlink" title="0～n-1中缺失的数字"></a>0～n-1中缺失的数字</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,2,3,4,5,6,7,9]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>

<p>限制：1 &lt;= 数组长度 &lt;= 10000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int left&#x3D;0;</span><br><span class="line">        int right&#x3D;nums.size();</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            if(nums[mid]&#x3D;&#x3D;mid) left&#x3D;mid+1;</span><br><span class="line">            else right&#x3D;mid;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-55-I 二叉树的深度(DFS,回溯)</title>
    <url>/2020/08/04/%E5%89%91-55-I-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<p> </p>
<p>提示：节点总数 &lt;= 10000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int max&#x3D;0;</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line">    </span><br><span class="line">    int maxDepth(TreeNode* root) &#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void depth(TreeNode* root)&#123;</span><br><span class="line">        if(root&#x3D;&#x3D;NULL) return;</span><br><span class="line">        count++;</span><br><span class="line">        if(count&gt;max)max&#x3D;count;</span><br><span class="line">        depth(root-&gt;left);</span><br><span class="line">        depth(root-&gt;right);</span><br><span class="line">        count--;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-54  二叉搜索树的第k大节点(中序遍历，反过来)</title>
    <url>/2020/08/04/%E5%89%91-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h3 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a>二叉搜索树的第k大节点</h3><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">     3   6</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   4</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p>限制：1 ≤ k ≤ 二叉搜索树元素个数</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p><strong>搜索二叉树</strong>（又：二叉查找树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthLargest(TreeNode* root, int k) &#123;</span><br><span class="line">         vector&lt;int&gt; result;</span><br><span class="line">        dfs(result, root);</span><br><span class="line">        return result[k-1];</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void dfs(vector&lt;int&gt; &amp;result, TreeNode *node) &#123;</span><br><span class="line">        if (node &#x3D;&#x3D; nullptr) return;</span><br><span class="line">        dfs(result, node-&gt;right);&#x2F;&#x2F;中序：左中右，从小到大。右中左，从大到小。</span><br><span class="line">        result.push_back(node-&gt;val);</span><br><span class="line">        dfs(result, node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;搜索二叉树的中序遍历本身就递增的从小到大</span><br><span class="line">    &#x2F;&#x2F;二叉树遍历  递归  栈</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-55-II 平衡二叉树(先序，后序)</title>
    <url>/2020/08/04/%E5%89%91-55-II-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<p> </p>
<p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>
<p>返回 false 。</p>
<p> </p>
<p>限制：1 &lt;= 树的结点个数 &lt;= 10000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>方法一：先序遍历每一个节点，并比较左右子树高度，如果有&gt;1则返回false</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isBalanced(TreeNode* root) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;NULL) return true;</span><br><span class="line">        return balance(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool balance(TreeNode* root)&#123;&#x2F;&#x2F;判断左右子树是否平衡</span><br><span class="line">        if(root&#x3D;&#x3D;NULL) return true;</span><br><span class="line">        if(depth(root-&gt;left)-depth(root-&gt;right)&gt;1 || depth(root-&gt;left)-depth(root-&gt;right)&lt;-1 )&#123;</span><br><span class="line">             return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return balance(root-&gt;left)&amp;&amp;balance(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int depth(TreeNode* root)&#123;&#x2F;&#x2F;计算树的深度</span><br><span class="line">        if(root&#x3D;&#x3D;NULL) return 0;   </span><br><span class="line">        return max(depth(root-&gt;left),depth(root-&gt;right))+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：后序遍历每一个节点，时间复杂度小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*后序遍历解题*&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line">使用后序遍历的方式遍历二叉树的每个节点，那么在遍历到一个节点之前我们就已经</span><br><span class="line">遍历了它的左右子树。只要在每个节点的时候记录它的深度(某一节点的深度等于它到叶节点的路径的长度）</span><br><span class="line">就可以判断每个节点是不是平衡的</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	bool isBalanced(TreeNode* root)</span><br><span class="line">	&#123;</span><br><span class="line">		if (root &#x3D;&#x3D; nullptr) return true;</span><br><span class="line">		int depth &#x3D; 0;</span><br><span class="line">		return isBalanced(root, depth);&#x2F;&#x2F;root传入树，depth返回树的深度</span><br><span class="line">	&#125;</span><br><span class="line">	bool isBalanced(TreeNode* root,int &amp;pDepth) &#123;</span><br><span class="line">		if (root &#x3D;&#x3D; nullptr) &#123; pDepth &#x3D; 0; return true; &#125;&#x2F;&#x2F;空的深度为0</span><br><span class="line">		int left&#x3D;0,right&#x3D;0;</span><br><span class="line">		if (isBalanced(root-&gt;left, left) &amp;&amp; isBalanced(root-&gt;right, right))&#x2F;&#x2F;左右子树是平衡，然后开始判断左右的深度。</span><br><span class="line">		&#123;</span><br><span class="line">			int diff &#x3D; left - right;&#x2F;&#x2F;深度差</span><br><span class="line">			if (abs(diff) &lt;&#x3D; 1)</span><br><span class="line">			&#123;</span><br><span class="line">				pDepth &#x3D; 1 + (left &gt; right ? left : right);&#x2F;&#x2F;当前深度</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-56-I 数组中数字出现的次数(分组异或)</title>
    <url>/2020/08/04/%E5%89%91-56-I-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h3 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a>数组中数字出现的次数</h3><p>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>

<p>限制：2 &lt;= nums.length &lt;= 10000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p><img src="/img/14.png"></p>
<p><strong>算法</strong><br>先对所有数字进行一次异或，得到两个出现一次的数字的异或值。</p>
<p>在异或结果中找到任意为 1 的位。</p>
<p>根据这一位对所有的数字进行分组。</p>
<p>在每个组内进行异或操作，得到两个数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ret &#x3D; 0;</span><br><span class="line">        for (int n : nums)&#x2F;&#x2F;先对所有数字进行一次异或，得到两个出现一次的数字的异或值。</span><br><span class="line">            ret ^&#x3D; n;</span><br><span class="line">            </span><br><span class="line">        int div &#x3D; 1;&#x2F;&#x2F;可以直接使用int div &#x3D; ret &amp; (-ret)获取为 1 的位，解释见下方备注。</span><br><span class="line">        while ((div &amp; ret) &#x3D;&#x3D; 0)&#x2F;&#x2F;在异或结果中找到任意为 1 的位。</span><br><span class="line">            div &lt;&lt;&#x3D;1;&#x2F;&#x2F;左移赋值，没有&quot;&#x3D;&quot;(等号)则不改变div的值</span><br><span class="line">        int a &#x3D; 0, b &#x3D; 0;</span><br><span class="line">        </span><br><span class="line">        for (int n : nums)</span><br><span class="line">            if (div &amp; n)&#x2F;&#x2F;根据这一位对所有的数字进行分组。</span><br><span class="line">                a ^&#x3D; n;</span><br><span class="line">            else</span><br><span class="line">                b ^&#x3D; n;</span><br><span class="line">        return vector&lt;int&gt;&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        &#x2F;&#x2F;-6  原码1000 0110</span><br><span class="line">        &#x2F;&#x2F;    反码1111 1001</span><br><span class="line">        &#x2F;&#x2F;    补码1111 1010</span><br><span class="line">        &#x2F;&#x2F;s &amp; (-s) </span><br><span class="line">        &#x2F;&#x2F;  0000 0110</span><br><span class="line">        &#x2F;&#x2F;&amp; 1111 1010</span><br><span class="line">        &#x2F;&#x2F;  0000 0010</span><br><span class="line">        &#x2F;&#x2F;所以k &#x3D; s &amp; (-s) 就是保留s的最后一个1，并且将其他位变为0  也就是s最后一个1是倒数第二位</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-56-II 数组中数字出现的次数 II(位运算)</title>
    <url>/2020/08/04/%E5%89%91-56-II-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-II/</url>
    <content><![CDATA[<h3 id="数组中数字出现的次数-II"><a href="#数组中数字出现的次数-II" class="headerlink" title="数组中数字出现的次数 II"></a>数组中数字出现的次数 II</h3><p>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,3,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [9,1,7,9,7,9,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>限制：1 &lt;= nums.length &lt;= 10000, 1 &lt;= nums[i] &lt; 2^31</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>方法一：哈希表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; mp;</span><br><span class="line">        for(int n : nums) mp[n] ++;</span><br><span class="line">        int ans;</span><br><span class="line">        for(auto pr : mp)&#123;</span><br><span class="line">            if(pr.second &#x3D;&#x3D; 1)&#123;</span><br><span class="line">                ans &#x3D; pr.first;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：位运算</p>
<p>1.值得注意的是：如果某个数字出现3次，那么这个3个数字的和肯定能被3整除，则其对应二进制位的每一位的和也能被3整除</p>
<p>2.统计数组中每个数字的二进制中每一位的和，判断该和是否能被3整除。</p>
<p>3.若可以，则只出现一次的数字的二进制数中那一位为0，否则为1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 32; ++i)&#123;</span><br><span class="line">            int cnt &#x3D; 0;</span><br><span class="line">            for(int n : nums)&#123;</span><br><span class="line">                &#x2F;&#x2F; n &amp; 1 &lt;&lt; i 的值大于0即为真</span><br><span class="line">                if(n &amp; (1 &lt;&lt; i)) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 构造只出现一次的那个数字，采用异或的方法生成二进制中的每一位</span><br><span class="line">            if(cnt % 3 &#x3D;&#x3D; 1) ans ^&#x3D; (1 &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-57-II 和为s的连续正数序列(双指针)</title>
    <url>/2020/08/04/%E5%89%91-57-II-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a>和为s的连续正数序列</h3><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：target &#x3D; 15</span><br><span class="line">输出：[[1,2,3,4,5],[4,5,6],[7,8]]</span><br></pre></td></tr></table></figure>

<p>限制：1 &lt;= target &lt;= 10^5</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>方法一：枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123;</span><br><span class="line">        int m&#x3D;(target+1)&#x2F;2;</span><br><span class="line">        int count&#x3D;0;   </span><br><span class="line">        vector&lt;int&gt; a;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; b;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">            for(int j&#x3D;i;j&lt;&#x3D;m;j++)&#123;</span><br><span class="line">                count+&#x3D;j;</span><br><span class="line">                a.push_back(j);</span><br><span class="line">                if(count&#x3D;&#x3D;target)&#123;</span><br><span class="line">                    b.push_back(a);</span><br><span class="line">                    a.clear();</span><br><span class="line">                    count&#x3D;0;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(count&gt;target)&#123;</span><br><span class="line">                    a.clear();</span><br><span class="line">                    count&#x3D;0;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：双指针</p>
<p><img src="/img/15.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123;    </span><br><span class="line">         vector&lt;vector&lt;int&gt;&gt;vec;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        for (int l &#x3D; 1, r &#x3D; 2; l &lt; r;)&#123;</span><br><span class="line">            int sum &#x3D; (l + r) * (r - l + 1) &#x2F; 2;</span><br><span class="line">            if (sum &#x3D;&#x3D; target)&#123;</span><br><span class="line">                res.clear();</span><br><span class="line">                for (int i &#x3D; l; i &lt;&#x3D; r; ++i) res.push_back(i);</span><br><span class="line">                vec.emplace_back(res);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (sum &lt; target) r++;</span><br><span class="line">            else l++;</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-57  和为s的两个数字(哈希，双指针，二分查找)</title>
    <url>/2020/08/04/%E5%89%91-57-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a>和为s的两个数字</h3><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,26,30,31,47,60], target &#x3D; 40</span><br><span class="line">输出：[10,30] 或者 [30,10]</span><br></pre></td></tr></table></figure>

<p>限制：1 &lt;= nums.length &lt;= 10^5, 1 &lt;= nums[i] &lt;= 10^6</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>方法一：哈希表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; hash;</span><br><span class="line">        for(auto x: nums)&#123;</span><br><span class="line">            if(hash.count(target-x))&#123;&#x2F;&#x2F;计算hash中target-x的数量</span><br><span class="line">                return vector&lt;int&gt;&#123;x,target-x&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hash.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;int&gt;&#123;-1,-1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>方法二：双指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left&#x3D;0;</span><br><span class="line">        vector&lt;int&gt; a;</span><br><span class="line">        int right&#x3D;nums.size()-1;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            if(nums[mid]&gt;&#x3D;target) right&#x3D;mid;</span><br><span class="line">            else left&#x3D;mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        int m&#x3D;0;</span><br><span class="line">        int n&#x3D;left;</span><br><span class="line">        while(m&lt;n)&#123;</span><br><span class="line">            if((nums[m]+nums[n])&gt;target) n--;</span><br><span class="line">            else if((nums[m]+nums[n])&lt;target) m++;</span><br><span class="line">            else&#123;   </span><br><span class="line">                a.push_back(nums[m]);</span><br><span class="line">                a.push_back(nums[n]);</span><br><span class="line">                return a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法三：二分查找法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.size();++i)&#123;</span><br><span class="line">            if(binary_search(nums.begin()+i+1,nums.end(),target - nums[i]))&#123;&#x2F;&#x2F;binary_search查找有没有目标数值</span><br><span class="line">                return vector&lt;int&gt;&#123;nums[i],target - nums[i]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;int&gt;&#123;-1,-1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-58-I 翻转单词顺序(拼接字符，字符流)</title>
    <url>/2020/08/04/%E5%89%91-58-I-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无空格字符构成一个单词。</span><br><span class="line">输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line">如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>方法一：一个个单词存进栈再取出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseWords(string s) &#123;</span><br><span class="line">        string tmp&#x3D;&quot;&quot;;</span><br><span class="line">        stack&lt;string&gt; t;</span><br><span class="line">        int n&#x3D;s.size()+1;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;&#x2F;&#x2F;拼接单词放入栈中</span><br><span class="line">            if(s[i]!&#x3D;&#39; &#39; &amp;&amp; s[i]!&#x3D;&#39;\0&#39;)&#123;</span><br><span class="line">                tmp&#x3D;tmp+s[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if(s[i]&#x3D;&#x3D;&#39; &#39; || s[i]&#x3D;&#x3D;&#39;\0&#39;)&#123;</span><br><span class="line">                if(tmp!&#x3D;&quot;&quot;)&#123;</span><br><span class="line">                    t.push(tmp);</span><br><span class="line">                    &#x2F;&#x2F;tmp.clear();</span><br><span class="line">                    tmp&#x3D;&quot;&quot;;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string result&#x3D;&quot;&quot;;</span><br><span class="line">        while(!t.empty())&#123;&#x2F;&#x2F;取出栈中的单词</span><br><span class="line">            result+&#x3D;t.top();</span><br><span class="line">            t.pop();</span><br><span class="line">            result+&#x3D;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        result &#x3D; result.substr(0, result.size() - 1);&#x2F;&#x2F;去除多的那个空格</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：与方法一一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseWords(string s) &#123;</span><br><span class="line">    </span><br><span class="line">std::string reverseWords(std::string s) &#123;</span><br><span class="line">    if (s.empty()) &#123;</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string ansStr;</span><br><span class="line">    &#x2F;&#x2F; 存储所有单词的栈</span><br><span class="line">    std::stack&lt;std::string&gt; strStk;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 存放当前临时单词的字符串</span><br><span class="line">    std::string tempStr;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 遍历字符串s</span><br><span class="line">    for (char i : s) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果当前字符不为空或结束字符</span><br><span class="line">        if (i !&#x3D; &#39; &#39; &amp;&amp; i !&#x3D; &#39;\0&#39;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 则将当前字符加入当前临时单词中</span><br><span class="line">            tempStr +&#x3D; i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果当前字符为空，</span><br><span class="line">            &#x2F;&#x2F; 且当前临时单词字符串大小不为0，</span><br><span class="line">            &#x2F;&#x2F; 则表示当前临时单词字符串对应的单词拼接完成</span><br><span class="line">            if (tempStr.size() !&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 将单词入栈</span><br><span class="line">                strStk.push(tempStr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 重置当前临时单词字符串</span><br><span class="line">            tempStr.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将字符串最后的单词入栈</span><br><span class="line">    if (tempStr.size() !&#x3D; 0) &#123;</span><br><span class="line">        strStk.push(tempStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将栈顶单词和空字符串进行拼接</span><br><span class="line">    while (!strStk.empty()) &#123;</span><br><span class="line">        ansStr +&#x3D; strStk.top() + &quot; &quot;;</span><br><span class="line">        strStk.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 删除最后一个空字符</span><br><span class="line">    ansStr &#x3D; ansStr.substr(0, ansStr.size() - 1);</span><br><span class="line"></span><br><span class="line">    return ansStr;</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法三：字符流操作，非栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseWords(string s) &#123;</span><br><span class="line">        istringstream ss(s);</span><br><span class="line">        string res, str;</span><br><span class="line">        while(ss &gt;&gt; str)</span><br><span class="line">            res &#x3D; str + &#39; &#39; + res;</span><br><span class="line">        return res.substr(0, res.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法四：字符流操作，栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseWords(string s) &#123;</span><br><span class="line">        stack&lt;string&gt; stk;</span><br><span class="line">        string res,str;</span><br><span class="line">        istringstream ss(s);</span><br><span class="line">        while (ss &gt;&gt; str) stk.push(str), stk.push(&quot; &quot;);</span><br><span class="line">        if (!stk.empty()) stk.pop();&#x2F;&#x2F;去除栈顶部的空格字符</span><br><span class="line">        while (!stk.empty()) res +&#x3D; stk.top(), stk.pop();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-59-I 滑动窗口的最大值(deque，维护队列只存最大值)</title>
    <url>/2020/08/05/%E5%89%91-59-I-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h3 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h3><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</span><br><span class="line">输出: [3,3,5,5,6,7] </span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<p>提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>窗口左边是队尾，右边是队头。</p>
<p>队头存的是最大值的索引，队头到队尾递减。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        deque&lt;int&gt; deq;&#x2F;&#x2F;双端队列实现滑动窗口</span><br><span class="line">        int n &#x3D; nums.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">            while(!deq.empty() &amp;&amp; nums[i] &gt; nums[deq.back()])&#123;</span><br><span class="line">                deq.pop_back();&#x2F;&#x2F;清理尾部(左边)比即将放入值小的数值</span><br><span class="line">            &#125;</span><br><span class="line">            if (!deq.empty() &amp;&amp; deq.front() &lt; i - k + 1) deq.pop_front();</span><br><span class="line">            &#x2F;&#x2F;判断头部越界，即将放入的位置索引为i,判断队列里面队头的位置索引是否越界</span><br><span class="line">            deq.push_back(i);</span><br><span class="line">            if (i &gt;&#x3D; k -1) ans.push_back(nums[deq.front()]);&#x2F;&#x2F;将窗口内最大值存入</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-58-II 左旋转字符串(substr)</title>
    <url>/2020/08/05/%E5%89%91-58-II-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>

<p>限制：1 &lt;= k &lt; s.length &lt;= 10000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseLeftWords(string s, int n) &#123;</span><br><span class="line">       </span><br><span class="line">        string a&#x3D;s.substr(0,n);&#x2F;&#x2F;从位置0截取n个字符</span><br><span class="line">        string b&#x3D;s.substr(n,s.size()-n);&#x2F;&#x2F;从位置n截取s.size()-n个字符</span><br><span class="line">        string c&#x3D;b+a;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-59-II 队列的最大值(deque，维护队列最大值)</title>
    <url>/2020/08/05/%E5%89%91-59-II-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h3 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[1],[2],[],[],[]]</span><br><span class="line">输出: [null,null,null,2,1,2]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;]</span><br><span class="line">[[],[],[]]</span><br><span class="line">输出: [null,-1,-1]</span><br></pre></td></tr></table></figure>

<p>限制：1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000, 1 &lt;= value &lt;= 10^5</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MaxQueue &#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    deque&lt;int&gt; d;&#x2F;&#x2F;双头队列，保存队列最大值</span><br><span class="line">public:</span><br><span class="line">    MaxQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int max_value() &#123;&#x2F;&#x2F;队列到队尾递减</span><br><span class="line">        if (d.empty())</span><br><span class="line">            return -1;</span><br><span class="line">        return d.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push_back(int value) &#123;&#x2F;&#x2F;队列直接放</span><br><span class="line">    &#x2F;&#x2F;双头队列先判断队尾与要放入值的大小，删除比放入值小的所有数</span><br><span class="line">        while (!d.empty() &amp;&amp; d.back() &lt; value) &#123;</span><br><span class="line">            d.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        d.push_back(value);</span><br><span class="line">        q.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int pop_front() &#123;</span><br><span class="line">        if (q.empty())</span><br><span class="line">            return -1;</span><br><span class="line">        int ans &#x3D; q.front();&#x2F;&#x2F;取出队头元素</span><br><span class="line">        if (ans &#x3D;&#x3D; d.front()) &#123;&#x2F;&#x2F;判断取出的元素与deque队头元素是否相同</span><br><span class="line">            d.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-60 n个骰子的点数(由n-1次的情况推n次)</title>
    <url>/2020/08/05/%E5%89%91-60-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<h3 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a>n个骰子的点数</h3><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p> </p>
<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br></pre></td></tr></table></figure>
<p> </p>
<p>限制：1 &lt;= n &lt;= 11</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p><img src="/img/16.png"></p>
<p><strong>相应代码</strong></p>
<p>掷完n个骰子可能出现的点数是 n 到 6 * n。 即，上述公式j的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;double&gt; twoSum(int n) &#123;</span><br><span class="line">        int dp[15][70];</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 6; i ++) &#123;&#x2F;&#x2F;掷完1次骰子的各个点数可能次数</span><br><span class="line">            dp[1][i] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; n; i ++) &#123;&#x2F;&#x2F;掷骰子次数</span><br><span class="line">            for (int j &#x3D; i; j &lt;&#x3D; 6*i; j ++) &#123;&#x2F;&#x2F;掷i次骰子可能出现的点数值</span><br><span class="line">                for (int cur &#x3D; 1; cur &lt;&#x3D; 6; cur ++) &#123;</span><br><span class="line">                &#x2F;&#x2F;根据公式，即由掷完n-1次出现的点数可能，计算掷完n次骰子的点数可能。</span><br><span class="line">                    if (j - cur &lt;&#x3D; 0) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j] +&#x3D; dp[i-1][j-cur];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int all &#x3D; pow(6, n);&#x2F;&#x2F;总可能。</span><br><span class="line">        vector&lt;double&gt; ret;</span><br><span class="line">        for (int i &#x3D; n; i &lt;&#x3D; 6 * n; i ++) &#123;&#x2F;&#x2F;n次后的所有出现的点数值</span><br><span class="line">            ret.push_back(dp[n][i] * 1.0 &#x2F; all);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>空间优化后代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;double&gt; twoSum(int n) &#123;</span><br><span class="line">        int dp[70];</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 6; i ++) &#123;</span><br><span class="line">            dp[i] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; n; i ++) &#123;</span><br><span class="line">            for (int j &#x3D; 6*i; j &gt;&#x3D; i; j --) &#123;&#x2F;&#x2F;从大到小处理</span><br><span class="line">                dp[j] &#x3D; 0;&#x2F;&#x2F;需要覆盖原本值，所以需要先初始化</span><br><span class="line">                for (int cur &#x3D; 1; cur &lt;&#x3D; 6; cur ++) &#123;</span><br><span class="line">                    if (j - cur &lt; i-1) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[j] +&#x3D; dp[j-cur];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int all &#x3D; pow(6, n);</span><br><span class="line">        vector&lt;double&gt; ret;</span><br><span class="line">        for (int i &#x3D; n; i &lt;&#x3D; 6 * n; i ++) &#123;</span><br><span class="line">            ret.push_back(dp[i] * 1.0 &#x2F; all);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-61 扑克牌中的顺子(遍历)</title>
    <url>/2020/08/05/%E5%89%91-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</url>
    <content><![CDATA[<h3 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a>扑克牌中的顺子</h3><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,0,1,2,5]</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p>限制：</p>
<p>数组长度为 5 </p>
<p>数组的数取值为 [0, 13] .</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>思路：</p>
<p>1，遍历一遍统计大小王个数，并记录最小牌是哪张。</p>
<p>2，由最小牌开始递增，空的大小王补，补不上false，满足要求true。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isStraight(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int min&#x3D;INT_MAX;</span><br><span class="line">        int a[16]&#x3D;&#123;0&#125;;</span><br><span class="line">        for(int i&#x3D;0;i&lt;5;i++)&#123;</span><br><span class="line">            if(nums[i]&#x3D;&#x3D;0)&#123;&#x2F;&#x2F;统计大小王</span><br><span class="line">                a[0]++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums[i]&lt;min)&#x2F;&#x2F;寻找最小值</span><br><span class="line">                min&#x3D;nums[i];</span><br><span class="line">            a[nums[i]]&#x3D;1;&#x2F;&#x2F;标记有哪些牌，类似哈希表</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(int j&#x3D;0;j&lt;5;j++)&#123;&#x2F;&#x2F;从最小牌开始递增五次        </span><br><span class="line">            if(a[min]&#x3D;&#x3D;0 &amp;&amp; a[0]&#x3D;&#x3D;0) &#x2F;&#x2F;缺失且没有王补，false。</span><br><span class="line">                return false;</span><br><span class="line">            if(a[min]&#x3D;&#x3D;0)</span><br><span class="line">                a[0]-&#x3D;1;</span><br><span class="line">            min++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-62 圆圈中最后剩下的数字(递归思路，算法迭代)</title>
    <url>/2020/08/05/%E5%89%91-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h3><p>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 5, m &#x3D; 3</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 10, m &#x3D; 17</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>限制：1 &lt;= n &lt;= 10^5, 1 &lt;= m &lt;= 10^6</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p><strong>思路</strong></p>
<p>我们将上述问题建模为函数 f(n, m)，<label style="color:red"> 该函数的返回值为最终留下的元素的序号。</label></p>
<p>首先，长度为 n 的序列会先删除第 m % n 个元素，然后剩下一个长度为 n - 1 的序列。那么，我们可以递归地求解 f(n - 1, m)，就可以知道对于剩下的 n - 1 个元素，最终会留下第几个元素，我们设答案为 x = f(n - 1, m)。</p>
<p>由于我们删除了第 m % n 个元素，将序列的长度变为 n - 1。当我们知道了 f(n - 1, m) 留下的元素序号x后，我们也就可以知道，长度为 n 的序列最后一个删除的元素，应当是从 m % n 开始数的第 x 个元素。因此有<label style="color:red"> f(n, m) = (m % n + x) % n = (m + x) % n。</label></p>
<p>我们递归计算 f(n, m), f(n - 1, m), f(n - 2, m), … 直到递归的终点 f(1, m)。当序列长度为 1 时，一定会留下唯一的那个元素，它的编号为 0。</p>
<p>方法一：递归</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int f(int n, int m) &#123;</span><br><span class="line">        if (n &#x3D;&#x3D; 1)</span><br><span class="line">            return 0;</span><br><span class="line">        int x &#x3D; f(n - 1, m);</span><br><span class="line">        return (m + x) % n;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    int lastRemaining(int n, int m) &#123;</span><br><span class="line">        return f(n, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法二：方法一的递归可以改写为迭代，避免递归使用栈空间。</p>
<p><label style="color:red"> f(n, m) = (m % n + x) % n = (m + f(n-1, m)) % n。</label></p>
<p>即，f(n) = ( m + f(n-1) ) % n。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lastRemaining(int n, int m) &#123;</span><br><span class="line">        int f &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 2; i !&#x3D; n + 1; ++i)</span><br><span class="line">            f &#x3D; (m + f) % i;</span><br><span class="line">        return f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>单纯的思路就是建立一个n数组，然后删除第m个数。<br>每次对n更新(减一)，对m更新(m%n)<br>重复操作最后剩下的就是返回元素值。(这个思路时间复杂度太高)</p>
]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-63 股票的最大利润(min,max更新)</title>
    <url>/2020/08/05/%E5%89%91-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    <content><![CDATA[<h3 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a>股票的最大利润</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p>限制：0 &lt;= 数组长度 &lt;= 10^5</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        if(prices.size() &#x3D;&#x3D; 0)</span><br><span class="line">            return 0;</span><br><span class="line">        int minPrice &#x3D; prices[0];</span><br><span class="line">        int maxGap &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; prices.size(); i++)&#123;</span><br><span class="line">            minPrice &#x3D; min(minPrice, prices[i]); &#x2F;&#x2F; 更新最小值</span><br><span class="line">            maxGap &#x3D; max(maxGap, prices[i] - minPrice); &#x2F;&#x2F; 更新最大值</span><br><span class="line">        &#125;</span><br><span class="line">        return maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-65 不用加减乘除做加法(异或求和，与操作左移求进位)</title>
    <url>/2020/08/06/%E5%89%91-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。</p>
<p> </p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: a &#x3D; 1, b &#x3D; 1</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>提示：a, b 均可能是负数或 0, 结果不会溢出 32 位整数</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 位运算</span><br><span class="line"> *</span><br><span class="line"> * 因为不能使用加减乘除四则运算，所以只能想到使用二进制的位运算实现相加操作。</span><br><span class="line"> * 二进制位运算中，异或操作: 1^1&#x3D;0 0^0&#x3D;0 1^0&#x3D;1 0^1&#x3D;1，可以模拟无进位的加操作；</span><br><span class="line"> * 与操作：1&amp;1&#x3D;1 0&amp;1&#x3D;0 1&amp;0&#x3D;0 0&amp;0&#x3D;0，可以模拟进位的情况，再将与后的值左移一位即等于进位值。</span><br><span class="line"> *</span><br><span class="line"> * 普通的十进制数相加过程是：</span><br><span class="line"> * 1) 各位相加，无进位和 2) 计算进位值 3) 无进位和加上进位值</span><br><span class="line"> *</span><br><span class="line"> * 使用位运算的二进制数的相加过程相同：</span><br><span class="line"> * 1) 两个二进制数各位异或，得到无进位的和 2) 二进制数各位与再左移，计算进位 3) 无进位和与进位异或</span><br><span class="line"> * 重复上面操作，直到不再有进位，即进位为0。</span><br><span class="line"> *</span><br><span class="line"> * 相关问题：</span><br><span class="line"> * 不使用新的变量，交换两个变量的值。比如有两个变量a、b，希望交换它们的值。有两种不同的操作：</span><br><span class="line"> * 1. 基于加减法 -- a &#x3D; a + b; b &#x3D; a - b; a &#x3D; a - b;</span><br><span class="line"> * 2. 基于位运算 -- a &#x3D; a ^ b; b &#x3D; a ^ b; a &#x3D; a ^ b;</span><br><span class="line"> * *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/img/1.jpg"></p>
<p>计算 3+7 的值，其中 s 表示每一步不考虑进位的求和，c 表示每一步的进位。</p>
<p>因为是二进制，所以不考虑进位求和的话，可以直接采用异或运算。而计算进位的话，直接用位与和左移一位就行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int add(int a, int b) &#123;</span><br><span class="line">         while(b !&#x3D; 0)  &#x2F;&#x2F;b&#x3D;&#x3D;0说明已经无法进位了</span><br><span class="line">        &#123;</span><br><span class="line">            int temp &#x3D; (a ^ b);  &#x2F;&#x2F;相加,不考虑进位的加的结果</span><br><span class="line">            b &#x3D; ((unsigned int)(a &amp; b) &lt;&lt; 1);  </span><br><span class="line">            &#x2F;&#x2F;进位，注意：C++不支持负值左移！！这里要加上unsigned int</span><br><span class="line">            a &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-64 求1+2+…+n(A &amp;&amp; B,A递归出口，B主体函数)</title>
    <url>/2020/08/06/%E5%89%91-64-%E6%B1%821-2-%E2%80%A6-n/</url>
    <content><![CDATA[<h3 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a>求1+2+…+n</h3><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure>

<p>限制：1 &lt;= n &lt;= 10000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>以逻辑运算符 &amp;&amp; 为例，对于 A &amp;&amp; B 这个表达式，如果 A 表达式返回 False ，那么 A &amp;&amp; B 已经确定为 False ，此时不会去执行表达式 B。</p>
<p>将判断是否为递归的出口看作 A &amp;&amp; B 表达式中的 A 部分，递归的主体函数看作 B 部分。如果不是递归出口，则返回 True，并继续执行表达式 B 的部分，否则递归结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int sumNums(int n) &#123;</span><br><span class="line">        n &amp;&amp; (n +&#x3D; sumNums(n-1));</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-66 构建乘积数组(对称遍历)</title>
    <url>/2020/08/07/%E5%89%91-66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h3><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p>
<p> </p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure>

<p>提示：所有元素乘积之和不会溢出 32 位整数, a.length &lt;= 100000</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p><strong>对称遍历</strong></p>
<p>从左往右遍历累乘，结果保存在数组 ret 中，此时 ret[i] 表示，A[i] 左边所有元素的乘积</p>
<p>然后从右往左遍历累乘，获取 A[i] 右边所有元素的乘积</p>
<p>两边遍历之后得到的 ret，就是最终结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; constructArr(vector&lt;int&gt;&amp; a) &#123;</span><br><span class="line">        int n &#x3D; a.size();</span><br><span class="line">        vector&lt;int&gt; ret(n, 1);</span><br><span class="line">        int left &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i ++) &#123;</span><br><span class="line">            ret[i] *&#x3D; left;</span><br><span class="line">            left &#x3D; left * a[i];</span><br><span class="line">        &#125; </span><br><span class="line">        int right &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; n-1; i &gt;&#x3D; 0; i --) &#123;</span><br><span class="line">            ret[i] *&#x3D; right;</span><br><span class="line">            right *&#x3D; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>剑-67 把字符串转换成整数(isdigit,判断数字字符)</title>
    <url>/2020/08/07/%E5%89%91-67-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h3 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h3><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p> </p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure>
<p>示例 4:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure>
<p>示例 5:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>isdigit(str[0]),用于检查其参数是否为十进制数字字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int strToInt(string str) &#123;</span><br><span class="line">        long int res &#x3D; 0;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        int flag &#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F; 1. 检查空格</span><br><span class="line">        while (str[i] &#x3D;&#x3D; &#39; &#39;) &#123; i++; &#125;</span><br><span class="line">        &#x2F;&#x2F; 2. 检查符号</span><br><span class="line">        if (str[i] &#x3D;&#x3D; &#39;-&#39;) &#123; flag &#x3D; -1; &#125;</span><br><span class="line">        if (str[i] &#x3D;&#x3D; &#39;+&#39; || str[i] &#x3D;&#x3D; &#39;-&#39;) &#123; i++; &#125;</span><br><span class="line">        &#x2F;&#x2F; 3. 计算数字</span><br><span class="line">        while (i &lt; str.size() &amp;&amp; isdigit(str[i])) &#123; &#x2F;&#x2F;isdigit(str[0]),用于检查其参数是否为十进制数字字符。</span><br><span class="line">            int r &#x3D; str[i] - &#39;0&#39;;</span><br><span class="line">            res &#x3D; res * 10 + r;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; ------ 4. 处理溢出，这是关键步骤 ------</span><br><span class="line">            if (res &gt;&#x3D; INT_MAX &amp;&amp; flag &#x3D;&#x3D; 1) return  INT_MAX;&#x2F;&#x2F;INT_MAX(2^31 − 1)</span><br><span class="line">            if (res &gt; INT_MAX &amp;&amp; flag &#x3D;&#x3D; -1) return  INT_MIN;&#x2F;&#x2F;INT_MIN (−2^31) </span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return flag &gt; 0 ? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-68-I 二叉搜索树的最近公共祖先(节点俩侧)</title>
    <url>/2020/08/07/%E5%89%91-68-I-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="/img/17.png">
 </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p>说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        if((root -&gt; val - p-&gt;val)*(root -&gt; val - q -&gt;val) &lt;&#x3D; 0 )&#123;&#x2F;&#x2F;在当前结点俩头</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root -&gt; val &gt; p -&gt; val)&#123;&#x2F;&#x2F;在当前结点左边</span><br><span class="line">            return lowestCommonAncestor(root -&gt; left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root -&gt; val &lt; p -&gt; val)&#123;&#x2F;&#x2F;在当前结点右边</span><br><span class="line">            return lowestCommonAncestor(root -&gt; right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
  </entry>
  <entry>
    <title>剑-68-II 二叉树的最近公共祖先(左右子树寻找)</title>
    <url>/2020/08/07/%E5%89%91-68-II-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="/img/18.png"></p>
<p> </p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p>说明:所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。</p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p>在二叉搜索树时，我们可以通过判断节点p的值与当前节点的值，来判断节点p是否在当前节点的左右子树。<br>对于普通二叉树我们其实也可以利用递归来实现。</p>
<p><strong>代码思路为：</strong><br>递归查询两个节点p q，如果某个节点等于节点p或节点q，则返回该节点的值给父节点。<br>如果当前节点的左右子树分别包括p和q节点，那么这个节点必然是所求的解。<br>如果当前节点有一个子树的返回值为p或q节点，则返回该值。（告诉父节点有一个节点存在其子树中）<br>如果当前节点的两个子树返回值都为空，则返回空指针。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        &#x2F;&#x2F;先找到p或者q就返回，找到p，q返回，如果另一个在其下则返回的怕p，q就是祖先</span><br><span class="line">        if(root &#x3D;&#x3D; NULL || root &#x3D;&#x3D; p || root &#x3D;&#x3D; q) return root;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;在左子树找p或q，假如p和q都在左子树，返回的那个值就是祖先</span><br><span class="line">        TreeNode *left &#x3D; lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        &#x2F;&#x2F;在右子树找p或者q，假如p和q都在右子树，返回的那个值就是祖先</span><br><span class="line">        TreeNode *right &#x3D; lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        </span><br><span class="line">        if(left &#x3D;&#x3D; NULL) return right;</span><br><span class="line">        if(right &#x3D;&#x3D; NULL) return left;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; p和q一个在左子树一个在右子树</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>刷题</category>
        <category>剑指</category>
      </categories>
      <tags>
        <tag>剑指留意</tag>
      </tags>
  </entry>
  <entry>
    <title>vector(动态数组)</title>
    <url>/2020/08/12/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-vector/</url>
    <content><![CDATA[<h4 id="vector初始化："><a href="#vector初始化：" class="headerlink" title="vector初始化："></a>vector初始化：</h4><p>方式1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义具有10个整型元素的向量（尖括号为元素类型名，它可以是任何合法的数据类型），不具有初值，其值不确定</span><br><span class="line">vector&lt;int&gt;a(10);</span><br></pre></td></tr></table></figure>
<p>方式2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义具有10个整型元素的向量，且给出的每个元素初值为1</span><br><span class="line">vector&lt;int&gt;a(10,1);</span><br></pre></td></tr></table></figure>
<p>方式3.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;用向量b给向量a赋值，a的值完全等价于b的值</span><br><span class="line">vector&lt;int&gt;a(b);</span><br></pre></td></tr></table></figure>
<p>方式4.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;将向量b中从0-2（共三个）的元素赋值给a，a的类型为int型</span><br><span class="line">vector&lt;int&gt;a(b.begin(),b.begin+3);</span><br></pre></td></tr></table></figure>
<p>方式5.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F;从数组中获得初值</span><br><span class="line">int b[7]&#x3D;&#123;1,2,3,4,5,6,7&#125;;</span><br><span class="line">vector&lt;int&gt; a(b,b+7）;</span><br></pre></td></tr></table></figure>



<h4 id="vector对象的常用内置函数使用（举例说明）"><a href="#vector对象的常用内置函数使用（举例说明）" class="headerlink" title="vector对象的常用内置函数使用（举例说明）"></a>vector对象的常用内置函数使用（举例说明）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;vector&gt;</span><br><span class="line">vector&lt;int&gt; a,b;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;b为向量，将b的0-2个元素赋值给向量a</span><br><span class="line">a.assign(b.begin(),b.begin()+3);</span><br><span class="line">&#x2F;&#x2F;将n个值为x的元素赋值给a</span><br><span class="line">a.assign(4,2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回a的最后一个元素</span><br><span class="line">a.back();</span><br><span class="line">&#x2F;&#x2F;返回a的第一个元素</span><br><span class="line">a.front();</span><br><span class="line">&#x2F;&#x2F;返回a的第i元素,当且仅当a存在</span><br><span class="line">a[i];</span><br><span class="line">&#x2F;&#x2F;清空a中的元素</span><br><span class="line">a.clear();</span><br><span class="line">&#x2F;&#x2F;判断a是否为空，空则返回true，非空则返回false</span><br><span class="line">a.empty();</span><br><span class="line">&#x2F;&#x2F;删除a向量的最后一个元素</span><br><span class="line">a.pop_back();</span><br><span class="line">&#x2F;&#x2F;在a的最后一个向量后插入一个元素，其值为5</span><br><span class="line">a.push_back(5);&#x2F;&#x2F;emplace_back()取代push_back()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除a中第一个（从第0个算起）到第二个元素，</span><br><span class="line">&#x2F;&#x2F;也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束</span><br><span class="line">a.erase(a.begin()+1,a.begin()+3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在a的第一个元素（从第0个算起）位置插入数值5,</span><br><span class="line">a.insert(a.begin()+1,5);</span><br><span class="line">&#x2F;&#x2F;在a的第一个元素（从第0个算起）位置插入3个数，其值都为5</span><br><span class="line">a.insert(a.begin()+1,3,5);</span><br><span class="line">&#x2F;&#x2F;b为数组，在a的第一个元素（从第0个元素算起）的位置插入b的第三个元素到第5个元素（不包括b+6）</span><br><span class="line">a.insert(a.begin()+1,b+3,b+6);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回a中元素的个数</span><br><span class="line">a.size();</span><br><span class="line">&#x2F;&#x2F;返回a在内存中总共可以容纳的元素个数</span><br><span class="line">a.capacity();</span><br><span class="line">&#x2F;&#x2F;将a的现有元素个数调整至10个，多则删，少则补，其值随机</span><br><span class="line">a.resize(10);</span><br><span class="line">&#x2F;&#x2F;将a的现有元素个数调整至10个，多则删，少则补，其值为2</span><br><span class="line">a.resize(10,2);</span><br><span class="line">&#x2F;&#x2F;将a的容量扩充至100，</span><br><span class="line">a.reserve(100);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;b为向量，将a中的元素和b中的元素整体交换</span><br><span class="line">a.swap(b);</span><br><span class="line">&#x2F;&#x2F;b为向量，向量的比较操作还有 !&#x3D; &gt;&#x3D; &gt; &lt;&#x3D; &lt;</span><br><span class="line">a&#x3D;&#x3D;b;</span><br></pre></td></tr></table></figure>

<h4 id="对向量a添加元素的几种方式"><a href="#对向量a添加元素的几种方式" class="headerlink" title="对向量a添加元素的几种方式"></a>对向量a添加元素的几种方式</h4><p>1.向向量a中添加元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt;a;</span><br><span class="line">for(int i&#x3D;0;i&lt;10;++i)&#123;a.push_back(i);&#125;</span><br></pre></td></tr></table></figure>

<p>2.从数组中选择元素向向量中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[6]&#x3D;&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">vector&lt;int&gt; b;</span><br><span class="line">for(int i&#x3D;0;i&lt;&#x3D;4;++i)&#123;b.push_back(a[i]);&#125;</span><br></pre></td></tr></table></figure>

<p>3.从现有向量中选择元素向向量中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[6]&#x3D;&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">vector&lt;int&gt;b;</span><br><span class="line">vector&lt;int&gt;c(a,a+4);</span><br><span class="line">for(vector&lt;int&gt;::iterator it&#x3D;c.begin();it&lt;c.end();++it)</span><br><span class="line">&#123;</span><br><span class="line">	b.push_back(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.从文件中读取元素向向量中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifstream in(&quot;data.txt&quot;);</span><br><span class="line">vector&lt;int&gt;a;</span><br><span class="line">for(int i;in&gt;&gt;i)&#123;a.push_back(i);&#125;</span><br></pre></td></tr></table></figure>

<label style="color:red"> 
5.常见错误赋值方式</label>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt;a;</span><br><span class="line">for(int i&#x3D;0;i&lt;10;++i)&#123;a[i]&#x3D;i;&#125;&#x2F;&#x2F;下标只能用来获取已经存在的元素，初始化后可以这样改变值。</span><br></pre></td></tr></table></figure>

<h4 id="从向量中读取元素"><a href="#从向量中读取元素" class="headerlink" title="从向量中读取元素"></a>从向量中读取元素</h4><p>1.通过下标方式获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[6]&#x3D;&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">vector&lt;int&gt;b(a,a+4);</span><br><span class="line">for(int i&#x3D;0;i&lt;&#x3D;b.size()-1;++i)&#123;cout&lt;&lt;b[i]&lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure>

<p>2.通过迭代器方式读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a[6]&#x3D;&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">vector&lt;int&gt;b(a,a+4);</span><br><span class="line">for(vector&lt;int&gt;::iterator it&#x3D;b.begin();it!&#x3D;b.end();it++)&#123;cout&lt;&lt;*it&lt;&lt;&quot;  &quot;;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="几个常用的算法"><a href="#几个常用的算法" class="headerlink" title="几个常用的算法"></a>几个常用的算法</h4> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">&#x2F;&#x2F;对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span><br><span class="line">sort(a.begin(),a.end());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span><br><span class="line">reverse(a.begin(),a.end());</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开始复制，覆盖掉原有元素</span><br><span class="line">copy(a.begin(),a.end(),b.begin()+1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span><br><span class="line"> find(a.begin(),a.end(),10);</span><br></pre></td></tr></table></figure>
<p> 元素不在返回值也不相同<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于返回迭代器的查找，通过判断find（a.begin(),a.end(),value）&#x3D;&#x3D;a.end()，来判断元素是否存在。</span><br><span class="line">对于string，通过a.find(val)&#x3D;&#x3D;string::npos判断。</span><br></pre></td></tr></table></figure></p>
<h4 id="vector-data"><a href="#vector-data" class="headerlink" title="vector :: data()"></a>vector :: data()</h4><p>vector :: data()是“ vector”头文件的库函数，用于访问矢量元素，它返回一个指针，该指针指向矢量内部用于存储元素的内存数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v1&#123; 10, 20, 30, 40, 50 &#125;;</span><br><span class="line"></span><br><span class="line">    int* ptr &#x3D; v1.data();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;using vector::data() function</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; v1.size(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;element at index &quot; &lt;&lt; i &lt;&lt; &quot; : &quot; &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line">        ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">element at index 0 : 10</span><br><span class="line">element at index 1 : 20</span><br><span class="line">element at index 2 : 30</span><br><span class="line">element at index 3 : 40</span><br><span class="line">element at index 4 : 50</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>STL容器</category>
      </categories>
  </entry>
  <entry>
    <title>基数排序</title>
    <url>/2020/08/18/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>算法步骤</strong></p>
<p>1.将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</p>
<p>2.从最低位开始，依次进行一次排序</p>
<p>3.从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</p>
<p><img src="/img/43.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;* 尾递归 *&#x2F;</span><br><span class="line"> </span><br><span class="line">int find_max(int *a, int len) &#123; &#x2F;&#x2F;找数组中最大值</span><br><span class="line">	int max &#x3D; a[0];</span><br><span class="line">	for (int i &#x3D; 1; i &lt; len; i++) &#123;</span><br><span class="line">		if (a[i] &gt; max) &#123;</span><br><span class="line">			max &#x3D; a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return max;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int find_weishu(int max) &#123; &#x2F;&#x2F;确定最大值的位数</span><br><span class="line">	int number &#x3D; 0;</span><br><span class="line">	while (max !&#x3D; 0) &#123;</span><br><span class="line">		max &#x2F;&#x3D; 10;</span><br><span class="line">		number +&#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return number;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int kth_digit(int number, int kth) &#123;  获取kth位的数值</span><br><span class="line">	number &#x2F;&#x3D; pow(10, kth);</span><br><span class="line">	return number % 10;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void radix_sort(int *a, int len)&#123;</span><br><span class="line">	int *temp[10];</span><br><span class="line">	int count[10] &#x3D; &#123; 0,0,0,0,0,0,0,0,0,0 &#125;; </span><br><span class="line">	int max &#x3D; find_max(a,len);</span><br><span class="line">	int max_digit &#x3D; find_weishu(max);</span><br><span class="line">	int i, j, k;</span><br><span class="line">	for (i &#x3D; 0; i &lt; 10; i++) &#123;  &#x2F;&#x2F;10个数，new创建10个组存放</span><br><span class="line">		temp[i] &#x3D; new int[len];</span><br><span class="line">		memset(temp[i], 0, sizeof(int)*len);</span><br><span class="line">	&#125;</span><br><span class="line">	for (i &#x3D; 0; i &lt; max_digit; i++) &#123; &#x2F;&#x2F;从最低位到最高位开始一个个比较。</span><br><span class="line">    </span><br><span class="line">		memset(count, 0, sizeof(int)*10);  &#x2F;&#x2F;重置计数数组</span><br><span class="line">        </span><br><span class="line">		for (j &#x3D; 0; j &lt; len; j++) &#123; &#x2F;&#x2F;遍历数组</span><br><span class="line">			int xx &#x3D; kth_digit(a[j], i); &#x2F;&#x2F;获取i位数值</span><br><span class="line">			temp[xx][count[xx]] &#x3D; a[j];  &#x2F;&#x2F;放入对应的分类组</span><br><span class="line">			count[xx]++;  &#x2F;&#x2F;并统计计数，后面根据先进先出再合并</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		int index &#x3D; 0;</span><br><span class="line">		for (j &#x3D; 0; j &lt; 10; j++) &#123;  &#x2F;&#x2F;遍历计数数组。</span><br><span class="line">			for (k &#x3D; 0; k &lt; count[j]; k++) &#123;  &#x2F;&#x2F;根据计数数组的数量进行合并。</span><br><span class="line">				a[index++] &#x3D; temp[j][k]; &#x2F;&#x2F;当前位数，数值为j的数，依次取出合并。</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;        </span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2020/08/17/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>算法步骤</strong></p>
<p>1.创建一个堆 H[0……n-1]；</p>
<p>2.把堆首（最大值）和堆尾互换；</p>
<p>3.把堆的尺寸缩小 1，并重新对array[0]进行处理，目的是把新的数组顶端数据调整到相应位置；</p>
<p>4.重复步骤 2，直到堆的尺寸为 1。</p>
<p><img src="/img/33.png"></p>
<p>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]  </p>
<p>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]  </p>
<p>当前节点 arr[j] 的父节点为 arr[(j-1)/2] 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void buildHeap(int array[], int size)  &#x2F;&#x2F;将无序数组调整为堆。</span><br><span class="line">&#123;</span><br><span class="line">	int i, tmp, index;</span><br><span class="line">	for (i &#x3D; (size-1) &#x2F; 2; i &gt;&#x3D; 0; i--)  &#x2F;&#x2F;从第一个非叶子节点开始</span><br><span class="line">	&#123;</span><br><span class="line">		tmp &#x3D; array[i];  &#x2F;&#x2F;tmp保存的是当前节点</span><br><span class="line">		index &#x3D; 2 * i+1;  &#x2F;&#x2F;当前节点i的左子节点</span><br><span class="line">		while (index &lt;&#x3D; size)</span><br><span class="line">		&#123;</span><br><span class="line">			if (index &lt; size &amp;&amp; array[index + 1] &gt; array[index]) index++;  </span><br><span class="line">            		&#x2F;&#x2F;取左右子节点较大值的下标。</span><br><span class="line">			if (array[index] &lt; tmp) break;  &#x2F;&#x2F;当前节点比左右子树都大，结束。</span><br><span class="line">			array[(index - 1) &#x2F; 2] &#x3D; array[index];  &#x2F;&#x2F;将较大值赋值给父节点。</span><br><span class="line">			index &#x3D; 2 * index+1;</span><br><span class="line">		&#125;</span><br><span class="line">		array[(index - 1) &#x2F; 2] &#x3D; tmp;  &#x2F;&#x2F;将tmp放到正确位置</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int  a[] &#x3D; &#123; 5, 3, 2, 1, 7, 6, 9, 8, 4 &#125;;</span><br><span class="line">	int size &#x3D; 9;</span><br><span class="line">	buildHeap(a, size-1); &#x2F;&#x2F;无序数组变成堆</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; size - 1; i &gt; 0; i--)&#123;   &#x2F;&#x2F;堆排序过程</span><br><span class="line">		int tt &#x3D; a[i];&#x2F;&#x2F;顶是最大值，和最后一个交换。</span><br><span class="line">		a[i] &#x3D; a[0];</span><br><span class="line">		a[0] &#x3D; tt;</span><br><span class="line"></span><br><span class="line">		size--;&#x2F;&#x2F;除去最大值后，重新构建堆。 </span><br><span class="line">		int tmp &#x3D; a[0];</span><br><span class="line">		int index &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		index &#x3D; index * 2 + 1;</span><br><span class="line">		while (index &lt;&#x3D;size-1)</span><br><span class="line">		&#123;	</span><br><span class="line">			if ((index ) &lt; size-1 &amp;&amp; a[index + 1] &gt; a[index]) index++;</span><br><span class="line">			if (a[index] &lt; tmp) break;&#x2F;&#x2F;当前节点比左右子树都大，结束。</span><br><span class="line">			a[(index-1) &#x2F; 2] &#x3D; a[index];</span><br><span class="line">			index &#x3D; 2 * index+1;</span><br><span class="line">		&#125;</span><br><span class="line">		a[(index-1) &#x2F; 2] &#x3D; tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; 9; i++)&#123;</span><br><span class="line">		cout &lt;&lt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>无序数组构建堆图解</strong></p>
<p>1.给定无序序列结构如下<img src="/img/34.png">  </p>
<p>2.从最后一个非叶子结点开始，即从最后一个节点的父节点开始。<img src="/img/35.png"> </p>
<p>3.下一个节点，即代码中buildHeap()中的 i- - 。 <img src="/img/36.png"><br>3.<br>          <img src="/img/37.png"></p>
<p>4.将堆顶元素与末尾元素进行交换，使末尾元素最大。</p>
<p><img src="/img/38.png"></p>
<p>5.将剩余的元素重新调整，使其继续满足堆定义。<br><img src="/img/39.png"></p>
<p>6.将堆顶元素与末尾元素进行交换，使末尾元素最大。</p>
<p><img src="/img/40.png"><br>7.后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序<br><img src="/img/41.png"></p>
<p><label style="color:red"> 无序数组构建堆，是将非叶子节点一个个处理完。<br>后续交换则只需要对根节点进行处理。</label></p>
]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/08/17/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>算法步骤</strong></p>
<p>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
<p>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
<p>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
<p>4.重复步骤 3 直到某一指针达到序列尾；</p>
<p>5.将另一序列剩下的所有元素直接复制到合并序列尾。</p>
<p><img src="/img/27.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void merge(int a[], int *left, int leftcount, int *right,int  rightcount)  &#x2F;&#x2F;合并过程</span><br><span class="line">&#123;</span><br><span class="line">	int i, j, k;</span><br><span class="line">	i &#x3D; 0, j &#x3D;0, k &#x3D; 0;</span><br><span class="line">	while (i &lt; leftcount&amp;&amp;j &lt; rightcount)</span><br><span class="line">	&#123;</span><br><span class="line">		if (left[i] &lt; right[j])</span><br><span class="line">			a[k++] &#x3D; left[i++];</span><br><span class="line">		else a[k++] &#x3D; right[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	while (i &lt; leftcount)a[k++] &#x3D; left[i++];</span><br><span class="line">	while (j &lt; rightcount)a[k++] &#x3D; right[j++];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void mergeSort(int a[], int n)  &#x2F;&#x2F;排序过程</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	if (n &lt; 2) return;</span><br><span class="line">    	int mid&#x3D;n&#x2F;2;</span><br><span class="line">	int *left &#x3D; new int[mid];</span><br><span class="line">	int *right &#x3D; new int[n - mid ];</span><br><span class="line">	for (int i &#x3D; 0; i &lt; mid; i++)</span><br><span class="line">		left[i] &#x3D; a[i];</span><br><span class="line">	for (int j &#x3D; mid ; j &lt; n; j++)</span><br><span class="line">		right[j-mid] &#x3D; a[j];</span><br><span class="line"> </span><br><span class="line">	mergeSort(left, mid);</span><br><span class="line">	mergeSort(right, n - mid);</span><br><span class="line">	merge(a,left,mid,right,n-mid);</span><br><span class="line"> </span><br><span class="line">	delete[] left;</span><br><span class="line">	delete[] right;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
  </entry>
  <entry>
    <title>插入排序,希尔排序</title>
    <url>/2020/08/17/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><strong>算法步骤</strong></p>
<p>1.将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
<p>2.从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void InsertionSort(int *a, int len)</span><br><span class="line">&#123;</span><br><span class="line">	for (int j&#x3D;1; j&lt;len; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		int key &#x3D; a[j];</span><br><span class="line">		int i &#x3D; j-1;</span><br><span class="line">		while (i&gt;&#x3D;0 &amp;&amp; a[i]&gt;key)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i+1] &#x3D; a[i];</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		a[i+1] &#x3D; key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>算法步骤</strong></p>
<p>1.选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p>
<p>2.按增量序列个数 k，对序列进行 k 趟排序；</p>
<p>3.每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<p><strong>算法示意图</strong></p>
<p><img src="/img/26.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ShellSort(int *a, int len)</span><br><span class="line">&#123;</span><br><span class="line">	int h &#x3D; 1;</span><br><span class="line">	while( h&lt;len ) </span><br><span class="line">		h &#x3D; 3*h + 1;	&#x2F;&#x2F;h是选定的增量序列</span><br><span class="line">	while( h&gt;0 )</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j&#x3D;h; j&lt;len; j++)	&#x2F;&#x2F;从h开始是因为插入排序默认第一个已经有序。</span><br><span class="line">		&#123;</span><br><span class="line">			int key &#x3D; a[j];</span><br><span class="line">			int i &#x3D; j-h;</span><br><span class="line">			while( i&gt;&#x3D;0 &amp;&amp; a[i]&gt;key )</span><br><span class="line">			&#123;</span><br><span class="line">				a[i+h] &#x3D; a[i];</span><br><span class="line">				i &#x3D; i-h;</span><br><span class="line">			&#125;</span><br><span class="line">			a[i+h] &#x3D; key;</span><br><span class="line">		&#125;</span><br><span class="line">		h  &#x3D; h&#x2F;3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/08/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>算法步骤</strong></p>
<p>1.从数列中挑出一个元素，称为 “基准”（pivot）;</p>
<p>2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
<p>3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p>
<p><img src="/img/28.png"><br><img src="/img/29.png"><br><img src="/img/30.png"><br><img src="/img/31.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;快速排序（从小到大）</span><br><span class="line">void quickSort(int left, int right, vector&lt;int&gt;&amp; arr)</span><br><span class="line">&#123;</span><br><span class="line">	if(left &gt;&#x3D; right)</span><br><span class="line">		return;</span><br><span class="line">        </span><br><span class="line">   	if(left &lt; 0 || right &gt;&#x3D; arr.size())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;error args! array bound.&quot; &lt;&lt; endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;&#x2F;&#x2F;非法输入判断,防止数组越界</span><br><span class="line">    </span><br><span class="line">	int i, j, base, temp;</span><br><span class="line">	i &#x3D; left, j &#x3D; right;</span><br><span class="line">	base &#x3D; arr[left];  &#x2F;&#x2F;取最左边的数为基准数</span><br><span class="line">	while (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		while (arr[j] &gt;&#x3D; base &amp;&amp; i &lt; j)</span><br><span class="line">			j--;</span><br><span class="line">		while (arr[i] &lt;&#x3D; base &amp;&amp; i &lt; j)</span><br><span class="line">			i++;</span><br><span class="line">		if(i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			temp &#x3D; arr[i];</span><br><span class="line">			arr[i] &#x3D; arr[j];</span><br><span class="line">			arr[j] &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;基准数归位</span><br><span class="line">	arr[left] &#x3D; arr[i];</span><br><span class="line">	arr[i] &#x3D; base;</span><br><span class="line">	quickSort(left, i - 1, arr);&#x2F;&#x2F;递归左边</span><br><span class="line">	quickSort(i + 1, right, arr);&#x2F;&#x2F;递归右边</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






















]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/08/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++面经</category>
      </categories>
  </entry>
  <entry>
    <title>汉诺塔问题</title>
    <url>/2020/08/28/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>有三根杆子A，B，C。A杆上有N个(N&gt;1)穿孔圆环，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆：<br>1,每次只能移动一个圆盘；<br>2,大盘不能叠在小盘上面。<br>提示：可将圆盘临时置于B杆，也可将从A杆移出的圆盘重新移回A杆，但都必须遵循上述两条规则。</p>
<p>问：如何移？最少要移动多少次？<br><img src="/img/48.png"></p>
<p>为了解决这个问题，不妨假设已经知道怎样移动N-1个圆环了。现在，为了把起点盘上的圆环移动到目标盘，需要做如下操作：</p>
<p>1、把N-1个圆环从起点盘移动到（当前）没有任何圆环的过度盘；</p>
<p>2、把最后一个圆环从起点盘移动到目标盘；</p>
<p>3、把N-1个圆环从国度盘移动到目标盘（模仿1和2的操作方法来实现）。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">void hannoi (int n, char A, char B, char C)　　&#x2F;&#x2F; 把A盘里面的圆圈转移到C盘里面【A--C】。</span><br><span class="line">&#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;移动圆圈&quot; &lt;&lt; n &lt;&lt; &quot;从盘&quot; &lt;&lt; A &lt;&lt; &quot;盘&quot; &lt;&lt; C &lt;&lt; endl;　　&#x2F;&#x2F;把最后一个圆环从起点盘移动到目标盘。</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        hannoi (n-1, A, C, B);　　</span><br><span class="line">        &#x2F;&#x2F; 把N-1个圆环从起点盘移动到（当前）没有任何圆环的过度盘；</span><br><span class="line">        &#x2F;&#x2F;通过B、C盘在此函数调用中调用位置的互换，来实现把N-1个圆环从A盘到B盘的转移【A--B】。</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; &quot;移动圆圈&quot; &lt;&lt; n &lt;&lt; &quot;从盘&quot; &lt;&lt; A &lt;&lt; &quot;盘&quot; &lt;&lt; C &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">        hannoi (n-1, B, A, C);　　</span><br><span class="line">        &#x2F;&#x2F; 把N-1个圆环从国度盘移动到目标盘（模仿1和2的操作方法来实现）；</span><br><span class="line">        &#x2F;&#x2F;通过A、B盘在此函数调用中位置的互换，来实现N-1个圆环从B盘到C盘的转移【B--C】。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    hannoi (n, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>收藏题</category>
      </categories>
  </entry>
  <entry>
    <title>程序员面试宝典</title>
    <url>/2020/09/07/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">杀杀杀杀杀杀杀杀杀</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++面经</category>
      </categories>
  </entry>
  <entry>
    <title>桶排序</title>
    <url>/2020/08/18/%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>算法步骤</strong></p>
<p>1.设置固定数量的空桶。</p>
<p>2.把数据放到对应的桶中。</p>
<p>3.对每个不为空的桶中数据进行排序。</p>
<p>4.拼接不为空的桶中数据，得到结果</p>
<p><img src="/img/42.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 桶排序</span><br><span class="line"> *</span><br><span class="line"> * 参数说明：</span><br><span class="line"> *     a -- 待排序数组</span><br><span class="line"> *     n -- 数组a的长度</span><br><span class="line"> *     max -- 数组a中最大值的范围</span><br><span class="line"> *&#x2F;</span><br><span class="line">void bucketSort(int* a, int n, int max)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    int *buckets;</span><br><span class="line"></span><br><span class="line">    if (a&#x3D;&#x3D;NULL || n&lt;1 || max&lt;1)</span><br><span class="line">        return ;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建一个容量为max的数组buckets，并且将buckets中的所有数据都初始化为0。</span><br><span class="line">    if ((buckets &#x3D; new int[max])&#x3D;&#x3D;NULL)</span><br><span class="line">        return ;</span><br><span class="line">    memset(buckets, 0, max*sizeof(int));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1. 计数</span><br><span class="line">    for(i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">        buckets[a[i]]++;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2. 排序</span><br><span class="line">    for (i &#x3D; 0, j &#x3D; 0; i &lt; max; i++)</span><br><span class="line">        while( (buckets[i]--) &gt;0 )</span><br><span class="line">            a[j++] &#x3D; i;</span><br><span class="line"></span><br><span class="line">    delete[] buckets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
  </entry>
  <entry>
    <title>网易面试_DFS_(商品均分俩份价值相同，多余扔除)</title>
    <url>/2020/08/08/%E7%BD%91%E6%98%93%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h3 id="给一堆（最多15）有价值的东西，均分给2个人，均分不了的，扔掉，求最小扔掉多少？"><a href="#给一堆（最多15）有价值的东西，均分给2个人，均分不了的，扔掉，求最小扔掉多少？" class="headerlink" title="给一堆（最多15）有价值的东西，均分给2个人，均分不了的，扔掉，求最小扔掉多少？"></a>给一堆（最多15）有价值的东西，均分给2个人，均分不了的，扔掉，求最小扔掉多少？</h3><p><img src="/img/19.png"></p>
<p><img src="/img/20.png"></p>
<h3 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h3><p><strong>思路：</strong></p>
<p>从第一个商品开始，它只有三个命运。<br>1，给第一个人。2，给第二个人。3，扔掉。<br>进行深搜处理。<br>1，当俩个人持有的价值相同则更新一下最后要扔的数值。即，剩下没分配的+已经扔掉的。<br>2，当商品分配完毕，深搜结束。<br>3，当俩人差距超过剩余商品总价值，深搜结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int a[20];&#x2F;&#x2F;存价值</span><br><span class="line">int suffixSum[20];</span><br><span class="line">int n;</span><br><span class="line">int minLoss;</span><br><span class="line">void dfs(int first, int second, int cost, int index)&#x2F;&#x2F;first第一个人，second第二个人，cost扔掉。</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt;&#x3D; n)&#x2F;&#x2F;超过，深搜结束。</span><br><span class="line">    &#123;</span><br><span class="line">        if (first &#x3D;&#x3D; second)&#x2F;&#x2F;相等更新，因为价值分发完毕了，只需要cost。</span><br><span class="line">            minLoss &#x3D; min(minLoss, cost);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (first &#x3D;&#x3D; second)&#x2F;&#x2F;俩人价值相等minLoss更新下。</span><br><span class="line">        minLoss &#x3D; min(minLoss, suffixSum[index] + cost);</span><br><span class="line">    if (abs(first - second) &gt; suffixSum[index])&#x2F;&#x2F;俩人差值已经超过剩余所有价值和，结束。</span><br><span class="line">        return;</span><br><span class="line">    &#x2F;&#x2F; 给first，给second，扔掉</span><br><span class="line">    dfs(first + a[index], second, cost, index + 1);</span><br><span class="line">    dfs(first, second + a[index], cost, index + 1);</span><br><span class="line">    dfs(first, second, cost + a[index], index + 1);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; ++i)</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">        memset(suffixSum, 0, sizeof(suffixSum));</span><br><span class="line">        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; --i)</span><br><span class="line">        &#x2F;&#x2F;存的是价值和，suffixSum[0]是总和，suffixSum[1]是总和减去a[0].即，当前往后所有价值和。</span><br><span class="line">            suffixSum[i] &#x3D; suffixSum[i + 1] + a[i];&#x2F;&#x2F;理解思路suffixSum[i+1] &#x3D; suffixSum[i ] - a[i];</span><br><span class="line">        minLoss &#x3D; INT32_MAX;</span><br><span class="line">        dfs(0, 0, 0, 0);</span><br><span class="line">        cout &lt;&lt; minLoss &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题</category>
        <category>收藏题</category>
      </categories>
      <tags>
        <tag>题目新颖思路</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序</title>
    <url>/2020/08/18/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>算法步骤</strong></p>
<p>1.花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max</p>
<p>2.开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)</p>
<p>3.数组 B 中 index 的元素记录的值是 A 中某元素出现的次数</p>
<p>4.最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void coutSort(int* data, int length)</span><br><span class="line">&#123;</span><br><span class="line">    if (data &#x3D;&#x3D; nullptr || length &lt;&#x3D; 0)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;确定数列最大值</span><br><span class="line">    int max &#x3D; data[0];</span><br><span class="line">    int min &#x3D; data[0];</span><br><span class="line">    for (int i &#x3D; 1; i &lt; length; ++i)&#123;</span><br><span class="line">        if (data[i] &gt; max)</span><br><span class="line">            max &#x3D; data[i];</span><br><span class="line">        if (data[i] &lt; min)</span><br><span class="line">            min &#x3D; data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    int d &#x3D; max - min;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 确定统计数组长度并进行初始化</span><br><span class="line">    int* coutData &#x3D; new int[d + 1];</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; d; ++i)</span><br><span class="line">        coutData[i] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 遍历数组，统计每个数出现的次数</span><br><span class="line">    for (int i &#x3D; 0; i &lt; length; ++i)</span><br><span class="line">            ++coutData[data[i] - min];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 排序数组，某个数出现了几次，便在data里累计输出几次</span><br><span class="line">    int index &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; max; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; coutData[i]; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            data[index++] &#x3D; i+min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/2020/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++面经</category>
      </categories>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/08/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h4><p>问题描述：有n件物品和容量为m的背包 给出i件物品的重量以及价值 求解让装入背包的物品重量不超过背包容量 且价值最大 。<br>特点:这是最简单的背包问题，特点是每个物品只有一件供你选择放还是不放。</p>
<p><img src="/img/44.png"></p>
<p><strong>图片中abc三个公式详细解析：</strong><br>a式表示前𝑖个物品中挑选放入承重为0的背包中和没有物品放入承重为𝑗的背包中是相等为0。 </p>
<p>b式表明：如果第𝑖个物品的重量大于背包的容量，则装人前𝑖个物品得到的最大价值和装入前𝑖−1个物品得到的最大价是相同的，即物品𝑖不能装入背包。 </p>
<p>c式表明：如果第𝑖个物品的重量小于背包的容量，则会有一下两种情况：<br>(1)如果把第𝑖个物品装入背包，则背包物品的价值等于第𝑖−1个物品装入容量位𝑗−𝑊_𝑖 的背包中的价值加上第𝑖个物品的价值𝑉_𝑖;<br>(2)如果第𝑖个物品没有装入背包，则背包中物品价值就等于把前𝑖−1个物品装入容量为𝑗的背包中所取得的价值。显然，取二者中价值最大的作为把前𝑖个物品装入容量为𝑗的背包中的最优解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int V[200][200];&#x2F;&#x2F;前i个物品装入容量为j的背包中获得的最大价值</span><br><span class="line"></span><br><span class="line">int KnapSack(int n, int w[], int v[], int x[], int C)</span><br><span class="line">&#123;</span><br><span class="line">	int i, j;</span><br><span class="line">	for (i &#x3D; 0; i &lt;&#x3D; n; i++)&#x2F;&#x2F;背包容量为0的初始化。</span><br><span class="line">		V[i][0] &#x3D; 0;</span><br><span class="line">	for (j &#x3D; 0; j &lt;&#x3D; C; j++)&#x2F;&#x2F;前0个物品的初始化。</span><br><span class="line">		V[0][j] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;  物品V[i+1]对应重量w[i]，价值v[i]。</span><br><span class="line">	for (i &#x3D; 0; i &lt; n; i++)&#123;  &#x2F;&#x2F;前n个物品</span><br><span class="line">		for (j &#x3D; 0; j &lt; C + 1; j++)&#123;  &#x2F;&#x2F;从0到C的背包容量</span><br><span class="line">			if (j&lt;w[i]) &#x2F;&#x2F;当前容量j与当前物品重量w[i]比较。</span><br><span class="line">				V[i+1][j] &#x3D; V[i][j];  &#x2F;&#x2F;V[i+1]对应的是第几个物品，从1到n。</span><br><span class="line">			else</span><br><span class="line">				V[i+1][j] &#x3D; max(V[i][j], V[i ][j - w[i]] + v[i]); &#x2F;&#x2F;比较确定最优解</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	j &#x3D; C;</span><br><span class="line">	for (i &#x3D; n - 1; i &gt;&#x3D; 0; i--)&#x2F;&#x2F;确定最后结果选中了哪些物品</span><br><span class="line">	&#123;</span><br><span class="line">		if (V[i+1][j]&gt;V[i][j])&#x2F;&#x2F;如果和前一个不一样，表示当前物品被选中了。</span><br><span class="line">		&#123;</span><br><span class="line">			x[i] &#x3D; 1;</span><br><span class="line">			j &#x3D; j - w[i];</span><br><span class="line">		&#125;</span><br><span class="line">		else&#x2F;&#x2F;如果和前一个一样，表示当前物品没有放入。</span><br><span class="line">			x[i] &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;选中的物品是:&quot; &lt;&lt; endl;</span><br><span class="line">	for (i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">		cout &lt;&lt; x[i]&lt;&lt;&quot;  &quot;;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt;&#x3D; n; i++)&#123; &#x2F;&#x2F;打印价值数组。</span><br><span class="line">		for (int j &#x3D; 0; j &lt; C + 1; j++)&#123;</span><br><span class="line">			cout &lt;&lt; V[i][j] &lt;&lt; &#39;\t&#39;;</span><br><span class="line">			if (j &#x3D;&#x3D; C)&#123;</span><br><span class="line">				cout&lt;&lt;endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return V[n][C];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int s;&#x2F;&#x2F;获得的最大价值</span><br><span class="line">	int w[5] &#x3D; &#123; 2, 2, 6, 5, 4 &#125;;&#x2F;&#x2F;物品的重量</span><br><span class="line">	int v[5] &#x3D; &#123; 6, 3, 5, 4, 6 &#125;;&#x2F;&#x2F;物品的价值</span><br><span class="line">	int x[5];&#x2F;&#x2F;物品的选取状态</span><br><span class="line">	int n &#x3D; 5;&#x2F;&#x2F;物品你数量</span><br><span class="line">	int C &#x3D; 10;&#x2F;&#x2F;背包最大容量</span><br><span class="line"></span><br><span class="line">	s &#x3D; KnapSack(n, w, v, x, C);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;最大物品价值为:&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/45.png"><br>一维数组优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][w]&#x3D;max&#123;dp[i-1][w],dp[i-1][w-wi]+vi&#125;</span><br><span class="line"></span><br><span class="line">f[w]&#x3D;max&#123;f[w], f[w-wi]+vi&#125;</span><br></pre></td></tr></table></figure>
<h5 id="附加简洁代码"><a href="#附加简洁代码" class="headerlink" title="附加简洁代码"></a>附加简洁代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N&#x3D;1100;</span><br><span class="line">int dp[N][N],w[N],v[N];&#x2F;&#x2F;w是物品重量，v是物品价值</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,C;&#x2F;&#x2F;物品数量和背包容量</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;C;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++) cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">		for(int j&#x3D;0;j&lt;&#x3D;C;j++)</span><br><span class="line">				dp[i][j]&#x3D;dp[i-1][j];&#x2F;&#x2F;不选</span><br><span class="line">				if(j&gt;v[i]) dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-w[i]]+v[i]);&#x2F;&#x2F;选</span><br><span class="line">	cout&lt;&lt;dp[n][C];</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简介优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N&#x3D;1100;</span><br><span class="line">int dp[N],w[N],v[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,C;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;C;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++) cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">		for(int j&#x3D;C;j&gt;&#x3D;v[i];j--)&#x2F;&#x2F;倒序,不然j-w[i]被更新了,导致计算错误。</span><br><span class="line">			dp[j]&#x3D;max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">	cout&lt;&lt;dp[n][C];</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><label style="color:red"> ================================================================================</label></p>
<h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><p>问题描述：有n件物品和容量为m的背包 给出i件物品的重量以及价值 求解让装入背包的物品重量不超过背包容量 且价值最大 。<br>特点：题干看似与背包问题一样 但它的特点是每个物品可以无限选用。</p>
<p><strong>问题分析</strong></p>
<p><label style="color:red"> 选择放进去</label><br>如果选择放进去，还需要考虑放进去多少个，即：<br>1, 2, 3, ···, k-1, k个<br>表示上一个物品的状态的时候，当前背包重量j需要减去当前k个物品的重量k<em>w[i]，并且整个背包的价值需要加上当前k个物品的价值k</em>v[i]，则状态方程为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] &#x3D; dp[i-1][j-k*w[i]] + k*v[i]</span><br></pre></td></tr></table></figure>

<p><label style="color:red"> 选择不放进去</label><br>实际上如果选择不放进去的时候，表示放进去的是0个，需要减去的kw[i]和需要加上的kv[i]都为0选择不放进去的状态方程则为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># dp[i][j] &#x3D; dp[i-1][j-0*w[i]] + 0*v[i]</span><br><span class="line">dp[i][j] &#x3D; dp[i-1][j]</span><br></pre></td></tr></table></figure>

<p><label style="color:red"> 由此我们可以得到状态转移方程：</label></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] &#x3D; max(dp[i-1][j-k*w[i]] + k*v[i], dp[i-1][j])</span><br></pre></td></tr></table></figure>
<p><strong>实现代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N&#x3D;1100;</span><br><span class="line">int dp[N][N],w[N],v[N];&#x2F;&#x2F;w是物品重量，v是物品价值。</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,C;&#x2F;&#x2F;物品数量和背包容量</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;C;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++) cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">		for(int j&#x3D;0;j&lt;&#x3D;C;j++)</span><br><span class="line">			for(int k&#x3D;0;k*w[i]&lt;&#x3D;j;k++)</span><br><span class="line">				dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-k*w[i]]+k*v[i]);</span><br><span class="line">                		&#x2F;&#x2F;当前物品放入0-k个数量，最优解保存。</span><br><span class="line">	cout&lt;&lt;dp[n][C];</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><label style="color:red"> 优化后的状态转移方程为：</label><br>优化后的状态转移方程去除了k。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i][j-w[i]]+v[i])</span><br><span class="line">&#x2F;&#x2F;dp[i][j-w[i]]+v[i]，前i个物品，容量为j-w[i]的最优解。</span><br><span class="line">&#x2F;&#x2F;如果可以放多个i那么在容量为j-w[i]时就已经放入了。</span><br><span class="line">&#x2F;&#x2F;所以此时只需要考虑一个就好了。</span><br></pre></td></tr></table></figure>
<p>优化后代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N&#x3D;1100;</span><br><span class="line">int dp[N][N],w[N],v[N];&#x2F;&#x2F;w是物品重量，v是物品价值。</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,C;&#x2F;&#x2F;物品数量和背包容量</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;C;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++) cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">		for(int j&#x3D;0;j&lt;&#x3D;C;j++)</span><br><span class="line">			for(int k&#x3D;0;k*w[i]&lt;&#x3D;j;k++)&#123;</span><br><span class="line">				dp[i][j]&#x3D;dp[i-1][j];&#x2F;&#x2F;不选</span><br><span class="line">				if(j&gt;v[i]) dp[i][j]&#x3D;max(dp[i][j],dp[i][j-w[i]]+v[i]);&#x2F;&#x2F;选</span><br><span class="line">				&#125;</span><br><span class="line">	cout&lt;&lt;dp[n][C];</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p><label style="color:red"> ================================================================================</label></p>
<h4 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h4><p>问题描述：有n件物品和容量为m的背包 给出i件物品的重量以及价值 还有数量 求解让装入背包的物品重量不超过背包容量 且价值最大 。<br>特点 ：它与完全背包有类似点 特点是每个物品都有了一定的数量。</p>
<p><strong>思路和完美背包差不多，区别只是k的确定。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N&#x3D;1100;</span><br><span class="line">int dp[N][N],w[N],v[N]s[N];&#x2F;&#x2F;w是物品重量，v是物品价值,s是物品数量。</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,C;&#x2F;&#x2F;物品数量和背包容量</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;C;</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++) cin&gt;&gt;w[i]&gt;&gt;v[i]&gt;&gt;s[i];</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">		for(int j&#x3D;0;j&lt;&#x3D;C;j++)</span><br><span class="line">			for(int k&#x3D;0;k*w[i]&lt;&#x3D;j&amp;&amp;k&lt;&#x3D;s[i];k++)</span><br><span class="line">				if(j&gt;v[i]) dp[i][j]&#x3D;max(dp[i][j],dp[i-1][j-k*w[i]]+k*v[i]);</span><br><span class="line">	cout&lt;&lt;dp[n][C];</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果优化为一维数组需要倒序，参考01背包。</p>
<p><label style="color:red"> ================================================================================</label></p>
<h4 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h4><p>问题描述<br>混合背包是01背包，完全背包，多重背包相互结合所产生的问题，即n种物品中，有的物品件数为1种，有的物品件数为有限数种，有的物品件数有无限数种，在这些物品中选取最优解（具体问题同01背包，此处不再详细，请参考前几篇文章）。</p>
<p><strong>问题分析</strong><br>这个问题其实跟01背包、完全背包、多重背包同源，可以使用同一种解决办法，只要在解决问题的时候牢牢记住，无限量的物品实际上等同于背包总容量与单间物品的重量相处所得的件数（最大使用量），因为即使物品数量再多也不可能使用到超过最大使用量的部分，又考虑到件数为1的情况是有限量中的特殊情况，所以，这个问题万万全全可以转换为一个多重背包问题，进而又可以通过多重背包问题转换成01背包问题求解。</p>
<p><label style="color:red"> ================================================================================</label></p>
<h4 id="二维成本背包问题"><a href="#二维成本背包问题" class="headerlink" title="二维成本背包问题"></a>二维成本背包问题</h4><p>问题描述<br>有n种物品，其中第i件物品的重量为w[i]，体积为v[i]，使用n[i]表示第i件物品的总数量，现有一个重量容量为wv，体积容量为vv的背包，求在两个指标均不超标的情况下，所能存放物品的最大价值。</p>
<p><strong>问题分析</strong><br>在二维成本背包中，使用f[i][wv][vv]表示从前i种商品中选取一定数量放在重量容量为wv，体积容量为vv的背包中所能存放的最大价值。考虑第i种物品的存取问题，使用f[i][wv - w[i] * n][vv - v[i] * n] + p[i] * n，表示第i种物品取了几件。（n可为0，0 &lt;= n &lt;= 最大使用量)。</p>
<p><label style="color:red"> ================================================================================</label></p>
<h4 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h4><p>问题描述<br>有n件物品，分为若干组，现约束，在每组物品里最多取一件物品放入背包，每件物品的重量确定，价值确定，背包容量确定，求在不超过背包容量的情况下，可以存放的最大价值。</p>
<p><strong>问题分析</strong><br>首先判断一个分组当中的一件物品，同01背包一样，此物品存在两种状态，取与不取，若取此物品，则继续判断下一组的第一件物品，若不取此物品，则继续判断本组下一件物品，若该物品为本组最后一件物品，则判断下一组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N&#x3D;110;</span><br><span class="line">int f[N][N],v[N][N],w[N][N],s[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;&#x2F;&#x2F; n组数，m背包容量</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];&#x2F;&#x2F;每组物品数</span><br><span class="line">        for(int j&#x3D;0;j&lt;s[i];j++)</span><br><span class="line">            cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;0;j&lt;&#x3D;m;j++)&#123;</span><br><span class="line">            f[i][j]&#x3D;f[i-1][j];</span><br><span class="line">            for(int k&#x3D;0;k&lt;s[i];k++)</span><br><span class="line">                if(v[i][k]&lt;&#x3D;j) f[i][j]&#x3D;max(f[i][j],f[i-1][j-v[i][k]]+w[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[n][m];</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>刷题</category>
        <category>收藏题</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/08/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++面经</category>
      </categories>
  </entry>
  <entry>
    <title>面试问题</title>
    <url>/2020/08/20/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h4><p><strong><font size=4>1.使用指针的要点和必要性</font></strong> </p>
<p>a.指针能够有效的表示数据结构<br>b.能动态分配内存，实现内存的自由管理<br>c.能方便的使用字符串<br>d.指针直接与数据的存储地址有关。比如：值传递不如地址传递高效，因为值传递先从实参的地址中取值，再赋值给形参代入函数计算。而指针则把形参的地址直接指向实参地址，使用时直接取出数据，效率提高。（这里形参的改变会影响实参的值）<br>**<font size=4>2.指针和引用的区别</font>** </p>
<p><strong>本质：</strong><br>引用是别名，指针是地址<br><strong>具体:</strong><br>a.指针可以被重新赋值以指向另一个对象，但是引用则总是在初始化时被指定的对象，以后不能改变(绑定对象不可变)，但是指向的内容可以改变。<br>b.程序为指针变量分配区域，而不为引用分配内存区域。因为引用生命时必须初始化，从而指向一个已经存在的对象，引用不能为空值。<br>c.因为用* 传参可能会指向空的地址或者错误的地址，所以要时时判断参数是否为空，导致降低效率。而用&amp;传参数，则参数不可能为空或者错误地址，这也算稍微提升了一些效率。</p>
<p><label style="color:red">===================================================================================== </label></p>
<h4 id="TCP连接与断开，socket"><a href="#TCP连接与断开，socket" class="headerlink" title="TCP连接与断开，socket"></a>TCP连接与断开，socket</h4><p><strong>三次握手建立连接：</strong></p>
<p>[Shake 1] 套接字A：“我想与你建立连接”<br>[Shake 2] 套接字B：“我知道了（ACK）,我这边已经准备好了，你现在能连吗（SYN）”<br>等待片刻后……<br>[Shake 3] 套接字B：“好的，咱们开始联通吧（ACK）”<br><img src="/img/46.png"></p>
<p><strong>四次握手断开连接：</strong></p>
<p>[Shake 1] 套接字A：“任务处理完毕，我希望断开连接。”<br>[Shake 2] 套接字B：“哦，是吗？请稍等，我准备一下。”<br>等待片刻后……<br>[Shake 3] 套接字B：“我准备好了，可以断开连接了。”<br>[Shake 4] 套接字A：“好的，谢谢合作。”</p>
<p><img src="/img/47.png"></p>
<p><label style="color:red">===================================================================================== </label></p>
<h4 id="const知识点问题"><a href="#const知识点问题" class="headerlink" title="const知识点问题"></a>const知识点问题</h4><p>const int * p;         // const修饰的是* p，因此* p是常量不能改变，但可以改变p的指向；<br>int const* p;         // 同上，主要是看const与* 的前后关系；<br>int* const p;         // const修饰的是p，因此p的指向是常量不能改变，但* p可以改变；<br>const int * const p;         // 两个const既修饰了* p也修饰了p，因此* p与p都是常量不能改变；</p>
<p><label style="color:red">===================================================================================== </label></p>
<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p><strong>区别：</strong></p>
<p>a.一个系统运行着很多进程，可以比喻为一条马路上有很多马车，不同的进程可以理解为不同的马车，同一辆马车可以有很多匹马来拉–这些马就是线程。<br>b.道路可以认为是临界资源，那么马车成为分配资源的最小单位(进程)，而同一个马车被很多匹马驱动(线程)–即最小的运行单位。</p>
<p><strong>线程间通信方式</strong><br><label style="color:red"> 两个进程间的两个线程通信，相当于进程间通信：</label><br>信号量, socket网络连接, 共享内存 ,管道,共享文件</p>
<p><label style="color:red"> 一个进程中的两个线程间通信方式：</label><br>1.互斥锁<br>2.条件变量condition_variable<br>3.信号量<br>4.读写锁shared_lock。</p>
<p>关于互斥锁和条件变量：<br>互斥量可以保护共享数据的修改，如果线程正在等待共享数据的某个条件出现，仅用互斥量的话就需要反复对互斥对象锁定解锁，以检查值的变化，这样将频繁查询的效率非常低。<br>条件变量可以让等待共享数据条件的线程进入休眠，并在条件达成时唤醒等待线程，提供一种更高效的线程同步方式。条件变量一般和互斥锁同时使用，提供一种更高效的线程同步方式。</p>
<p><label style="color:red">===================================================================================== </label></p>
<h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，</p>
<p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存</p>
<p>注：如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。<label style="color:red"> 这种场景就需要深拷贝</label></p>
<p><label style="color:red">===================================================================================== </label></p>
<h4 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h4><p><strong>单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。</strong><br>1.私有化该类的构造函数<br>2.通过new在本类中创建一个本类对象。<br>3.定义一个共有的方法将创建的对象返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton    </span><br><span class="line">&#123;  </span><br><span class="line">public:  </span><br><span class="line">    static Singleton* GetInstance()&#123;&#x2F;&#x2F;此方法时获得本类实例的唯一全局访问点</span><br><span class="line">    	if(singleton &#x3D;&#x3D; NULL)  </span><br><span class="line">        	singleton &#x3D; new Singleton();  </span><br><span class="line">    	return singleton; </span><br><span class="line">    &#125; </span><br><span class="line">private:  </span><br><span class="line">    Singleton() &#123;&#125;  &#x2F;&#x2F;构造函数让其private，这样就可以堵死外界利用new创建此实例的可能</span><br><span class="line">    static Singleton *singleton&#x3D;NULL;  </span><br><span class="line">&#125;;   </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p><strong>饿汉式</strong></p>
<p>饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先先创建出来，然后每次调用的时候，就不需要在判断，节省了运行时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static Singleton* GetInstance();</span><br><span class="line">private:</span><br><span class="line">    Singleton() &#123;&#125;</span><br><span class="line">    static Singleton *singleton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::GetInstance()</span><br><span class="line">&#123;</span><br><span class="line">    return singleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::singleton &#x3D; new Singleton();</span><br></pre></td></tr></table></figure>



<p><strong>懒汉式</strong><br>懒汉式是典型的时间换空间，就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    static Singleton* GetInstance();</span><br><span class="line">private:</span><br><span class="line">    Singleton() &#123;&#125;</span><br><span class="line">    static Singleton *singleton;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::GetInstance()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (singleton &#x3D;&#x3D; NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        Lock();</span><br><span class="line">        if (singleton &#x3D;&#x3D; NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            singleton &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        UnLock();</span><br><span class="line">    &#125;</span><br><span class="line">    return singleton;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::singleton &#x3D; NULL;</span><br></pre></td></tr></table></figure>



<p><label style="color:red">===================================================================================== </label></p>
<h4 id="同步，异步，互斥"><a href="#同步，异步，互斥" class="headerlink" title="同步，异步，互斥"></a>同步，异步，互斥</h4><p><strong>同步:</strong>   我吩咐你去做事情,同时我在一旁等待结果,直到你做完我才回家.<br><strong>异步:</strong>   我吩咐你去做事情,我直接回家,你做完后在通知我</p>
<p><strong>互斥：</strong><br>当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片         段，只能等到该进程运行完这个程序片段后才可以运行。<br><strong>同步：</strong><br>同进程之间的若干程序片断的运行必须严格按照规定的某种先后次序来运行，这种         先后次序依赖于要完成的特定的任务。</p>
<p><strong>生产者消费者模型</strong><br>生产者与生产者之间是互斥关系，消费者与消费者之间是互斥关系，生产者与消费者之间是<label style="color:red">同步与互斥关系。</label></p>
<p>BlockingQueue 在多线程编程中阻塞队列(Blocking Queue)是一种常用于实现生产者和消费者模型的数据结构。其与普通的队列区别在于，<label style="color:red">当队列为空时，从队列获取元素的操作将会被阻塞，直到队列中被放入了元素；当队列满时，往队列里存放元素的操作也会被阻塞，直到有元素被从队列中取出</label>(以上的操作都是基于不同的线程来说的，线程在对阻塞队列进程操作时会被阻塞)</p>
<p><label style="color:red">===================================================================================== </label></p>
<h4 id="c-11的新智能指针"><a href="#c-11的新智能指针" class="headerlink" title="c++11的新智能指针"></a>c++11的新智能指针</h4><p>unique_ptr(auto_ptr的升级)、shared_ptr以及weak_ptr</p>
<p>智能指针的行为类似常规指针，区别在于它负责自动释放所指向的对象。这两种智能指针的区别在于管理底层指针的方式：<label style="color:red"> shared_ptr 允许多个shared_ptr类型指针指向同一个对象；unique_ptr 则 “独占” 所指向的对象。标准库还定义了一个名为 weak_ptr 的伴随类，它是一种弱引用，指向 shared_ptr 所管理的对象。</label></p>
<p><strong>shared_ptr 类</strong></p>
<p>最安全的分配和使用动态内存的方法是调用一个名为 make_shared 的标准库函数。 此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr。</p>
<p><strong>unique_ptr 类</strong></p>
<p>一个 unique_ptr “拥有” 它所指向的对象。与 shared_ptr 不同，某个时刻只能有一个 unique_ptr 指向一个给定对象。当 unique_ptr 被销毁时，它所指向的对象也被销毁。</p>
<p><strong>weak_ptr 类</strong></p>
<p>weak_ptr 是一种不控制所指向对象生存期的智能指针，它指向由一个 shared_ptr 管理的对象。将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。即使有 weak_ptr 指向对象，对象也还是会被释放，因此，weak_ptr 的名字抓住了这种智能指针 “弱” 共享对象的特点。</p>
]]></content>
      <categories>
        <category>C++面经</category>
      </categories>
  </entry>
</search>
